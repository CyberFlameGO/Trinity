
var _presets_table = {

    'Basic plume': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":-0.022591910933594583,"sunLatitude":76.73485298771871,"sunLongitude":138.94571082309892,"exposure":2.350729850942127,"gamma":1.8195271655405811,"saturation":1.025551675122873,"anisotropy":0.5438412313677659,"extinctionScale":-0.5745008154789941,"emissionScale":1.6890836089273709,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.44760368272298295,"Nx":128,"Ny":512,"Nz":128,"max_timesteps":200,"expansion":0.1},"SIMULATION_STATE":{"gravity":0.037493287047502884,"buoyancy":0.7057559914824072,"radiationLoss":0.999,"blast_height":0.1,"blast_radius":0.022054874733825225,"blast_velocity":87.11675519860964,"blast_heat_flux":100,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.24392018305823482,0.27436140371452433,0.013395718376239856],"dust_scattering":[0.7156281176719081,0.7156281176719081,0.7156281176719081],"TtoKelvin":82.7057802518446},"CAMERA_STATE":{"pos":[192.8969529081517,588.0911138073966,708.4847645407577],"tar":[64,256,64],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":2.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0);\\n    T = Tambient;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<100.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow = blast_heat_flux * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        absorptionInflow = dust_absorption * dust_inflow_rate * radial_falloff;\\n      \\tscatteringInflow = dust_scattering * dust_inflow_rate * radial_falloff;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T *= radiationLoss;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    // Tbuoyancy is the reference temperature for buoyancy\\n    float buoyancy_force = gravity*buoyancy*(T - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T * TtoKelvin) * pow(T/100.0, 4.0);\\n  \\treturn emission;\\n}"}}
    `,

    'Flamethrower + sphere': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":-0.1549211593365456,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"exposure":2.350729850942127,"gamma":1.3232924840295135,"saturation":0.8601401146191838,"anisotropy":0.5438412313677659,"extinctionScale":-2.4268817595622223,"emissionScale":0.36579112489785715,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.6768641055810962,"Nx":160,"Ny":200,"Nz":160,"max_timesteps":600,"expansion":0.06616462420147567},"SIMULATION_STATE":{"gravity":0.005513718683456306,"buoyancy":1.8746643523751443,"radiationLoss":0.9948359613554485,"blast_height":0.1,"blast_radius":0.05844915640222292,"blast_velocity":0,"blast_heat_flux":51.832270771782575,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.5247606104630443,0.5783451399962777,0.11897711296939269],"dust_scattering":[0.9411644381390155,0.6458367660244194,0.6458367660244194],"TtoKelvin":59.548161781328105,"collider_radius":0.2536472825002126},"CAMERA_STATE":{"pos":[62.10872181629186,89.53334429555497,531.8537067530015],"tar":[68.42456293652904,65.97904095749078,85.83382054581217],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":2.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n// Collision\\nuniform float collider_radius;            // {\\"name\\":\\"collider_radius\\",  \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01, \\"default\\":0.5}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0);\\n    T = Tambient;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<400.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow = blast_heat_flux * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        absorptionInflow = dust_absorption * dust_inflow_rate * radial_falloff;\\n      \\tscatteringInflow = dust_scattering * dust_inflow_rate * radial_falloff;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T *= radiationLoss;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    // Tbuoyancy is the reference temperature for buoyancy\\n    float buoyancy_force = gravity*buoyancy*(T - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdSphere(vec3 X, in vec3 C, float r) { return length(X-C) - r; }\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n    // Return SDF of the collider surface.\\n\\t// (where the interior with SDF < 0.0 is a solid obstacle)\\n    return sdSphere(wsP, L/2.0, 0.5*L.x*collider_radius);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T * TtoKelvin) * pow(T/100.0, 4.0);\\n  \\treturn emission;\\n}"}}
    `,

    'Dye collision': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0.10766064510840156,0.08760210904838352,0.08760210904838352],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":0.5728897068796868,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"exposure":2.350729850942127,"gamma":1.3232924840295135,"saturation":0.8601401146191838,"anisotropy":0.5438412313677659,"extinctionScale":-0.5745008154789941,"emissionScale":-10,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.6768641055810962,"Nx":400,"Ny":128,"Nz":128,"max_timesteps":150,"expansion":0.06616462420147567},"SIMULATION_STATE":{"inject_radius":0.1654115605036892,"inject_offset":0.019849387260442705,"inject_period":56.23993057125433,"inject_velocity":8.160303651515333,"dye_inflow_rate":1,"dye1_absorption":[0.8038814604633849,0.12596041112083212,0.12596041112083212],"dye1_scattering":[0,0,0],"dye2_absorption":[0,1,0.17568847903600648],"dye2_scattering":[0,0,0]},"CAMERA_STATE":{"pos":[270.95254177289587,202.3163712118452,650.0248676340489],"tar":[232.58191153396174,9.987985979447894,63.30262682867766],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Injection geometry \\nuniform float inject_radius;              // {\\"name\\":\\"inject_radius\\",     \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01, \\"default\\":0.1}\\nuniform float inject_offset;              // {\\"name\\":\\"inject_offset\\",     \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.01, \\"default\\":0.1}\\nuniform float inject_period;              // {\\"name\\":\\"inject_period\\",     \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.01, \\"default\\":25.0}\\nuniform float inject_velocity;            // {\\"name\\":\\"inject_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Dust\\nuniform float dye_inflow_rate;            // {\\"name\\":\\"dye_inflow_rate\\",  \\"min\\":0.0, \\"max\\":100.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dye1_absorption;            // {\\"name\\":\\"dye1_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye1_scattering;            // {\\"name\\":\\"dye1_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye2_absorption;            // {\\"name\\":\\"dye2_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye2_scattering;            // {\\"name\\":\\"dye2_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.1415926;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0);\\n    T = Tambient;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    vec3 inject_center1 = vec3(0.1*L.x, (0.5+inject_offset)*L.y, 0.5*L.z);\\n    vec3 inject_center2 = vec3(0.9*L.x, (0.5-inject_offset)*L.y, 0.5*L.z);\\n  \\n    float r1 = length(wsP - inject_center1);\\n    float rt1 = r1/(inject_radius*L.y);\\n  \\n    float r2 = length(wsP - inject_center2);\\n    float rt2 = r2/(inject_radius*L.y);\\n    \\n    if (rt1 <= 1.0 && time<inject_period)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt1*rt1*(3.0 - 2.0*rt1));\\n        vInflow = vec3(1.0, 0.0, 0.0) * inject_velocity * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        absorptionInflow = dye1_absorption * dye_inflow_rate * radial_falloff;\\n      \\tscatteringInflow = dye1_scattering * dye_inflow_rate * radial_falloff;\\n    }\\n    if (rt2 <= 1.0 && time<inject_period)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt2*rt2*(3.0 - 2.0*rt2));\\n        vInflow = vec3(-1.0, 0.0, 0.0) * inject_velocity * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        absorptionInflow = dye2_absorption * dye_inflow_rate * radial_falloff;\\n      \\tscatteringInflow = dye2_scattering * dye_inflow_rate * radial_falloff;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n  \\treturn vec3(1.0);\\n}"}}
    `,

    'Ink mix': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":0.6392870967421813,"sunLatitude":31.0812622887005,"sunLongitude":83.36742649385936,"exposure":2.572082697836626,"gamma":1.3232924840295135,"saturation":1,"anisotropy":0.5438412313677659,"extinctionScale":0.2198724926139093,"emissionScale":-10,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1.2130956989140604,"NprojSteps":8,"vorticity_scale":0.05458930645113272,"Nx":400,"Ny":64,"Nz":400,"max_timesteps":500,"expansion":0},"SIMULATION_STATE":{"inject_radius":0.15,"inject_period":400,"inject_angle":360,"inject_velocity":10,"ink_inflow_rate":0.08822514173920439},"CAMERA_STATE":{"pos":[-99.91787681820443,518.1746084701348,-284.90238875094315],"tar":[182.19405199951484,-19.360856687738803,171.53567366309642],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Injection geometry \\nuniform float inject_radius;              // {\\"name\\":\\"inject_radius\\",     \\"min\\":0.0, \\"max\\":0.2,    \\"step\\":0.01, \\"default\\":0.01}\\nuniform float inject_period;              // {\\"name\\":\\"inject_period\\",     \\"min\\":0.0, \\"max\\":400.0,  \\"step\\":0.01, \\"default\\":25.0}\\nuniform float inject_angle;               // {\\"name\\":\\"inject_angle\\",      \\"min\\":0.0, \\"max\\":360.0,  \\"step\\":0.01, \\"default\\":0.0}\\nuniform float inject_velocity;            // {\\"name\\":\\"inject_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":50.0}\\n\\n// Ink\\nuniform float ink_inflow_rate;            // {\\"name\\":\\"ink_inflow_rate\\",  \\"min\\":0.0, \\"max\\":1.0,     \\"step\\":0.01, \\"default\\":1.0}\\n\\nfloat length2(vec3 v) { return dot(v, v); }\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat cos60;\\nfloat sin60;\\nfloat M_PI = 3.1415926;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tcos60 = 0.5;\\n    sin60 = sqrt(3.0)/2.0;\\n  \\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0);\\n    T = 0.0;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nvoid rotateXZ(inout vec3 v, float angle)\\n{\\n\\tfloat C = cos(angle);\\n  \\tfloat S = sin(angle);\\n  \\tv = vec3(C*v.x + S*v.z, v.y, -S*v.x + C*v.z);\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    float scale = 0.2*L.x;\\n    vec3 origin = L/2.0;\\n    vec3 inject_center1 = origin + scale*vec3(-1.0, 0.0, 0.0);\\n    vec3 inject_center2 = origin + scale*vec3( 1.0, 0.0, 0.0);\\n  \\tvec3 inject_center3 = origin + scale*vec3( cos60, 0.0, sin60);\\n    vec3 inject_center4 = origin + scale*vec3(-cos60, 0.0, sin60);\\n    vec3 inject_center5 = origin + scale*vec3(-cos60, 0.0,-sin60);\\n    vec3 inject_center6 = origin + scale*vec3( cos60, 0.0,-sin60);\\n  \\n  \\tfloat R = 0.5*L.y * inject_radius;\\n    float R2 = R*R;\\n  \\tvec3 center;\\n    vec3 color;\\n    bool hit = false;\\n  \\tif      (length2(wsP - inject_center1) <= R2) { hit = true; center = inject_center1; color = vec3(1.0, 0.0, 0.0); }\\n\\telse if (length2(wsP - inject_center2) <= R2) { hit = true; center = inject_center2; color = vec3(1.0, 1.0, 0.0); }\\n    else if (length2(wsP - inject_center3) <= R2) { hit = true; center = inject_center3; color = vec3(0.0, 1.0, 0.0); }\\n    else if (length2(wsP - inject_center4) <= R2) { hit = true; center = inject_center4; color = vec3(0.0, 1.0, 1.0); }\\n    else if (length2(wsP - inject_center5) <= R2) { hit = true; center = inject_center5; color = vec3(0.0, 0.0, 1.0); }\\n  \\telse if (length2(wsP - inject_center6) <= R2) { hit = true; center = inject_center6; color = vec3(1.0, 0.0, 1.0); }\\n  \\n    if (hit)\\n    {\\n        float swing_angle = radians(inject_angle) * sin(2.0*M_PI*time/inject_period);\\n        float r = length(wsP - center);\\n        float radial_falloff = max(0.0, 1.0 - r*r*(3.0 - 2.0*r));\\n        vInflow = normalize(origin-center) * inject_velocity * radial_falloff;\\n        rotateXZ(vInflow, swing_angle);\\n\\n        // Also inject absorbing/scattering medium\\n      \\tscatteringInflow = color * ink_inflow_rate * radial_falloff;\\n    }\\n}\\n\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n  \\treturn vec3(1.0);\\n}"}}
    `,

    'Nuke': `
{"RENDERER_STATE":{"Nraymarch":86,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.168637947177407,"sunLatitude":33.074072726190124,"sunLongitude":222.32735718279505,"exposure":2.350729850942127,"gamma":1.8195271655405811,"saturation":1.025551675122873,"anisotropy":0.5438412313677659,"extinctionScale":1.5432496187019762,"emissionScale":-0.07467155433950623,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":10,"vorticity_scale":0.7970038741865376,"Nx":192,"Ny":256,"Nz":192,"max_timesteps":170,"expansion":0.04411257086960219},"SIMULATION_STATE":{"gravity":0.009925328445660495,"buoyancy":0.15439399804360768,"radiationLoss":0.9849166989239843,"blast_height":0.10917861290226544,"blast_radius":0.1268236412501063,"blast_velocity":0.6506604203266324,"blast_heat_flux":60.65478494570302,"blast_duration":5.403789931526269,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.49115724721261056,0.5175724268946335,0.7156862745098039],"dust_scattering":[0.7843137254901961,0.5454915530225931,0.41522491349480967],"TtoKelvin":99.25328445660493},"CAMERA_STATE":{"pos":[-277.43671920142117,134.70154892723474,641.8866267087336],"tar":[138.89746999748652,64.42821481922769,47.20491043881753],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":2.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.0, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":500.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float blast_duration;             // {\\"name\\":\\"blast_duration\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":1.0,   \\"default\\":100.0}\\n\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0);\\n    T = Tambient;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary values due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<=blast_duration)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = sin(M_PI*time/blast_duration) * dir * blast_velocity * radial_falloff;\\n        Tinflow = time/blast_duration * blast_heat_flux * radial_falloff;\\n    }\\n  \\tif (wsP.y < L.y*0.05)\\n    {\\n\\t\\tabsorption = dust_absorption;\\n        scattering = dust_scattering;\\n    }\\n  \\n    // Apply thermal relaxation due to \\"radiation loss\\" \\n    T *= radiationLoss;\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    // Tbuoyancy is the reference temperature for buoyancy\\n    float buoyancy_force = gravity*buoyancy*(T - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T * TtoKelvin) * pow(T/100.0, 4.0);\\n  \\treturn emission;\\n}"}}
    `,

    'Nuke II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0.09496347558631295,0.16027772123843773,0.37254901960784315],"sunColor":[1,1,1],"sunPower":0.7716248093509881,"sunLatitude":31.089007037058025,"sunLongitude":170.7156492653605,"exposure":2.350729850942127,"gamma":1.8195271655405811,"saturation":1.0587017008704527,"anisotropy":0.5438412313677659,"extinctionScale":1.410911906093169,"emissionScale":-0.5157972630355285,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":10,"vorticity_scale":0.99,"Nx":192,"Ny":256,"Nz":192,"max_timesteps":170,"expansion":0.025},"SIMULATION_STATE":{"gravity":0.009925328445660495,"buoyancy":0.06616885630440329,"radiationLoss":0.9915335845544245,"blast_height":0.10917861290226544,"blast_radius":0.09373921309790466,"blast_velocity":1,"blast_heat_flux":170.9362121197085,"blast_duration":5.403789931526269,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.31718569780853517,0.4901960784313726,0.46984191600515646],"dust_scattering":[0.6920415224913494,0.8487685731732139,0.8823529411764706],"TtoKelvin":29.775985336981485},"CAMERA_STATE":{"pos":[-443.4309074581782,344.95012145238604,-425.5961857240841],"tar":[101.78077978967582,49.875941449583394,92.79771928822392],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":2.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.0, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":500.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float blast_duration;             // {\\"name\\":\\"blast_duration\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":1.0,   \\"default\\":100.0}\\n\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0);\\n    T = Tambient;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary values due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<=blast_duration)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = sin(M_PI*time/blast_duration) * dir * blast_velocity * radial_falloff;\\n        Tinflow = time/blast_duration * blast_heat_flux * radial_falloff;\\n    }\\n  \\tif (wsP.y < L.y*0.05)\\n    {\\n\\t\\tabsorption = dust_absorption;\\n        scattering = dust_scattering;\\n    }\\n  \\n    // Apply thermal relaxation due to \\"radiation loss\\" \\n    T *= radiationLoss;\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    // Tbuoyancy is the reference temperature for buoyancy\\n    float buoyancy_force = gravity*buoyancy*(T - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T * TtoKelvin) * pow(T/100.0, 4.0);\\n  \\treturn emission;\\n}"}}
    `,

    'Nuke III': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0.09496347558631295,0.16027772123843773,0.37254901960784315],"sunColor":[1,1,1],"sunPower":0.7716248093509881,"sunLatitude":31.089007037058025,"sunLongitude":170.7156492653605,"exposure":2.350729850942127,"gamma":1.8195271655405811,"saturation":1.0587017008704527,"anisotropy":0.5438412313677659,"extinctionScale":0.2198724926139093,"emissionScale":1.2487055717485607,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":10,"vorticity_scale":0.8843467645083499,"Nx":140,"Ny":400,"Nz":140,"max_timesteps":170,"expansion":0.025},"SIMULATION_STATE":{"gravity":0.009925328445660495,"buoyancy":0.5514071358700274,"radiationLoss":0.9760941847500638,"blast_height":0.09925328445660495,"blast_radius":0.09925328445660495,"blast_velocity":0.5514071358700274,"blast_heat_flux":419.0694232612209,"blast_duration":3.4187242423941697,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.31718569780853517,0.4901960784313726,0.46984191600515646],"dust_scattering":[0.6920415224913494,0.8487685731732139,0.8823529411764706],"TtoKelvin":52.93508504352263},"CAMERA_STATE":{"pos":[210.00000000000003,466.4000000000001,769.9999999999998],"tar":[70,200,70],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":2.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.0, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":500.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float blast_duration;             // {\\"name\\":\\"blast_duration\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":1.0,   \\"default\\":100.0}\\n\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0);\\n    T = Tambient;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary values due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<=blast_duration)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = sin(M_PI*time/blast_duration) * dir * blast_velocity * radial_falloff;\\n        Tinflow = time/blast_duration * blast_heat_flux * radial_falloff;\\n    }\\n  \\tif (wsP.y < L.y*0.05)\\n    {\\n\\t\\tabsorption = dust_absorption;\\n        scattering = dust_scattering;\\n    }\\n  \\n    // Apply thermal relaxation due to \\"radiation loss\\" \\n    T *= radiationLoss;\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    // Tbuoyancy is the reference temperature for buoyancy\\n    float buoyancy_force = gravity*buoyancy*(T - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T * TtoKelvin) * pow(T/100.0, 4.0);\\n  \\treturn emission;\\n}"}}
    `,

    'Vortex street': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0.5098039215686274,0.44482891195693963,0.44482891195693963],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.3009756597862143,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"exposure":3.4543341152286704,"gamma":1.224123841631461,"saturation":0.8601951319572427,"anisotropy":-0.051579726303552786,"extinctionScale":0.48454791783152373,"emissionScale":-3.1625515152116606,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":32,"vorticity_scale":0.0764250290315858,"Nx":512,"Ny":1024,"Nz":4,"max_timesteps":10000,"expansion":0},"SIMULATION_STATE":{"inflow_spacing":0.20953471163061044,"inflow_velocity":5.955197067396297,"collider_width":0.23159099706541153},"CAMERA_STATE":{"pos":[253.68376733641685,376.0385402751219,-1889.8119702419383],"tar":[268.1464794759416,410.93238765583925,47.71473516134489],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Inflow geometry \\nuniform float inflow_spacing;              // {\\"name\\":\\"inflow_spacing\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float inflow_velocity;             // {\\"name\\":\\"inflow_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Collider\\nuniform float collider_width;              // {\\"name\\":\\"collider_width\\",  \\"min\\":0.0, \\"max\\":1.0,   \\"step\\":0.01, \\"default\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat M_PI = 3.141592;\\nvoid init()\\n{\\n\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0, 0.0, 0.0);\\n    T = 0.0;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    if (wsP.y <= 0.03*L.y)\\n    {\\n        v = vec3(0.0, 1.0, 0.0) * inflow_velocity;\\n      \\n        float w = inflow_spacing*0.1*L.x;\\n        float ink = 0.0;\\n        float phase = 2.0*M_PI*wsP.x/w;\\n      \\tif (cos(phase)>0.0) \\n          ink = 1.0;\\n            \\n        vec3 color = vec3(abs(cos(0.1*phase)), abs(cos(0.2*phase)), abs(cos(0.3*phase)));\\n        absorption = ink * color;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 X, vec3 bmin, vec3 bmax)\\n{\\n  vec3 d = abs(X-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n    // Return SDF of the collider surface.\\n    // (where the interior with SDF < 0.0 is a solid obstacle)\\n    vec3 C = vec3(L.x/2.0, L.y/5.0, 0.0);  \\n    float W = 0.5*L.x*collider_width;\\n    float H =  0.01*L.y;\\n  \\tvec3 E = vec3(W, H, 1.0e6);\\n    return sdBox(wsP, C-E, C+E);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n  \\treturn vec3(0.0);\\n}"}}
    `,

    'Vortex street II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":96,"show_bounds":true,"skyColor":[0.5098039215686274,0.44482891195693963,0.44482891195693963],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.3009756597862143,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"exposure":2.572082697836626,"gamma":1.7534746920666873,"saturation":0.8271107038050411,"anisotropy":-0.051579726303552786,"extinctionScale":0.8815610556579418,"emissionScale":-3.1625515152116606,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":32,"vorticity_scale":0.0764250290315858,"Nx":512,"Ny":1024,"Nz":2,"max_timesteps":10000,"expansion":0},"SIMULATION_STATE":{"inflow_spacing":0.20953471163061044,"inflow_velocity":5.5,"collider_width":0.08},"CAMERA_STATE":{"pos":[360.60688826160015,361.10427889170853,-1888.8808683612183],"tar":[266.44043858816985,496.20148129509306,42.004397633908575],"near":1,"far":20000},"GUI_STATE":{"visible":false},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Inflow geometry \\nuniform float inflow_spacing;              // {\\"name\\":\\"inflow_spacing\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float inflow_velocity;             // {\\"name\\":\\"inflow_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Collider\\nuniform float collider_width;              // {\\"name\\":\\"collider_width\\",  \\"min\\":0.0, \\"max\\":1.0,   \\"step\\":0.01, \\"default\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat M_PI = 3.141592;\\nvoid init()\\n{\\n\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0, 0.0, 0.0);\\n    T = 0.0;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    if (wsP.y <= 0.03*L.y)\\n    {\\n        v = vec3(0.0, 1.0, 0.0) * inflow_velocity;\\n      \\n        float w = inflow_spacing*0.1*L.x;\\n        float ink = 0.0;\\n        float phase = 2.0*M_PI*wsP.x/w;\\n      \\tif (cos(phase)>0.0) \\n          ink = 1.0;\\n            \\n        vec3 color = vec3(abs(cos(0.1*phase)), abs(cos(0.2*phase)), abs(cos(0.3*phase)));\\n        absorption = ink * color;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 X, vec3 bmin, vec3 bmax)\\n{\\n\\tvec3 d = abs(X-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n\\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n                   in vec3 L)   // world-space extents of grid\\n{\\n  // Return SDF of the collider surface.\\n  // (where the interior with SDF < 0.0 is a solid obstacle)\\n  vec3 C = vec3(L.x/2.0, L.y/5.0, 0.0);  \\n  float W = 0.5*L.x*collider_width;\\n  float H =  0.01*L.y;\\n  vec3 E = vec3(W, H, 1.0e6);\\n  return sdBox(wsP, C-E, C+E);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n  \\treturn vec3(0.0);\\n}"}}
    `,

    'Vortex street III': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":96,"show_bounds":true,"skyColor":[0.5098039215686274,0.44482891195693963,0.44482891195693963],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.3009756597862143,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"exposure":3.4543341152286704,"gamma":1.4887992668490742,"saturation":0.5955197067396296,"anisotropy":-0.051579726303552786,"extinctionScale":0.8815610556579418,"emissionScale":-3.1625515152116606,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":76,"vorticity_scale":0.0764250290315858,"Nx":512,"Ny":1024,"Nz":2,"max_timesteps":10000,"expansion":0},"SIMULATION_STATE":{"inflow_spacing":0.16542214076100822,"inflow_velocity":8.601951319572429,"collider_width":0.20953471163061044},"CAMERA_STATE":{"pos":[254.816368090117,251.9474264002902,1596.9849538346484],"tar":[251.19037905450142,402.4281961600724,25.75114483409081],"near":1,"far":20000},"GUI_STATE":{"visible":false},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Inflow geometry \\nuniform float inflow_spacing;              // {\\"name\\":\\"inflow_spacing\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float inflow_velocity;             // {\\"name\\":\\"inflow_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Collider\\nuniform float collider_width;              // {\\"name\\":\\"collider_width\\",  \\"min\\":0.0, \\"max\\":1.0,   \\"step\\":0.01, \\"default\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat M_PI = 3.141592;\\nvoid init()\\n{\\n\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,            // world space center of current voxel\\n                        in vec3 L,              // world-space extents of grid\\n                        inout vec3 v,           // initial velocity\\n                        inout float T,          // initial temperature\\n                        inout vec3 absorption,  // initial per-channel absorption\\n                        inout vec3 scattering)  // initial per-channel scattering\\n{\\n    v = vec3(0.0, 0.0, 0.0);\\n    T = 0.0;\\n    absorption = vec3(0.0);\\n    scattering = vec3(0.0);      \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time in units of frames\\n            in vec3 L,                   // world-space extents of grid\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout float T,               // modify temperature in-place (defaults to no change)\\n            inout float Tinflow,         // temperature inflow rate (defaults to zero)\\n            inout vec3 absorption,       // modify dust absorption coeff.in-place (defaults to no change)\\n            inout vec3 absorptionInflow, // dust absorption coeff. inflow rate (defaults to 0)\\n            inout vec3 scattering,       // modify dust scattering coeff. in-place (defaults to no change)\\n            inout vec3 scatteringInflow  // dust scattering coeff. inflow rate (defaults to 0)\\n            )\\n{\\n    if (wsP.y <= 0.03*L.y)\\n    {\\n        v = vec3(0.0, 1.0, 0.0) * inflow_velocity;\\n      \\n        float w = inflow_spacing*0.1*L.x;\\n        float ink = 0.0;\\n        float phase = 2.0*M_PI*wsP.x/w;\\n      \\tif (cos(phase)>0.0) \\n          ink = 1.0;\\n            \\n        vec3 color = vec3(abs(cos(0.05*phase)), abs(sin(0.5*phase)), abs(sin(0.08*phase)));\\n        absorption = ink * color;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time in units of frames\\n                    in vec3 v, in float P, in float T, // velocity, pressure, temperature of current voxel\\n                    in vec3 L)                         // world-space extents of grid\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 X, vec3 bmin, vec3 bmax)\\n{\\n\\tvec3 d = abs(X-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n\\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP, // world space center of current voxel\\n    in vec3 L)   // world-space extents of grid\\n{\\n    // Return SDF of the collider surface.\\n    // (where the interior with SDF < 0.0 is a solid obstacle)\\n    vec3 C = vec3(L.x/2.0, L.y/5.0, 0.0);  \\n    float W = 0.5*L.x*collider_width;\\n    float H =  0.01*L.y;\\n    vec3 E = vec3(W, H, 1.0e6);\\n    return sdBox(wsP, C-E, C+E);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 temperatureToEmission(in float T)\\n{\\n  \\treturn vec3(0.0);\\n}"}}
    `



};


var Presets = function()
{
    this.preset_names = [];
    for (var preset_name in _presets_table) {
        if (_presets_table.hasOwnProperty(preset_name)) {
            this.preset_names.push(preset_name);
        }
    }
}

Presets.prototype.get_preset_names = function()
{
    return this.preset_names;
}

Presets.prototype.get_preset = function(preset_name)
{
    return this.preset_names[preset_name];
}

Presets.prototype.load_preset = function(preset_name)
{
    if (preset_name in _presets_table)
    {
        let preset = _presets_table[preset_name];
        let state = JSON.parse(preset);
        trinity.preset_selection = preset_name;
        trinity.load_state(state);
    }
}

