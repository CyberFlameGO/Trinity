
var _presets_table = {

    'Basic plume': `
{"RENDERER_STATE":{"Nraymarch":50,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":-0.022591910933594583,"sunLatitude":76.73485298771871,"sunLongitude":138.94571082309892,"colliderSpec":[0.5,0.5,0.5],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.2,"exposure":2.350729850942127,"gamma":1.8195271655405811,"saturation":1.025551675122873,"anisotropy":0.5438412313677659,"extinctionScale":-0.5959881967375598,"emissionScale":2.159026557340489,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":12,"vorticity_scale":0.4476323128992883,"Nx":128,"Ny":512,"Nz":128,"max_timesteps":200,"expansion":0.1},"SIMULATION_STATE":{"gravity":0.31523402185697563,"buoyancy":0.06192096857904879,"radiationLoss":0.999,"blast_height":0.1,"blast_radius":0.022516715846926834,"blast_velocity":100,"blast_heat_flux":81.0601770489366,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.24392018305823482,0.27436140371452433,0.013395718376239856],"dust_scattering":[0.7156281176719081,0.7156281176719081,0.7156281176719081],"TtoKelvin":97.94771393413171},"CAMERA_STATE":{"pos":[-624.0634897818458,283.27264122224386,553.0279493488317],"tar":[42.57196035861968,272.6939714310104,82.66879528244912],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"///////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation (velocity, temperature, and medium density/albedo)\\n// at time 0.0 (if unspecified, all quantities default to zero).\\n///////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature via either:\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//  - modification in-place, i.e. Dirichlet boundary conditions (v, T)\\n// Also specify the injected medium density inflow rate, and its scattering albedo.\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<200.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow.r = blast_heat_flux * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        vec3 dust_extinction = dust_absorption + dust_scattering;\\n        mediumInflow = dust_extinction * dust_inflow_rate * radial_falloff;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T.r *= radiationLoss;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    // Boussinesq approximation (a la Fedkiw & Stam)\\n    float densityAvg = (medium.r + medium.g + medium.b)/3.0;\\n    float buoyancy_force = -densityAvg*gravity + buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emiss\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify the phase function of the scattering medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Plume & sphere collider I': `
{"RENDERER_STATE":{"Nraymarch":32,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.1881091475283911,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"colliderSpec":[0.6666666666666667,0.6013071895424837,0.6013071895424837],"colliderDiffuse":[0.21568627450980393,0.21568627450980393,0.21568627450980393],"colliderRoughness":0.341872424239417,"exposure":2.350729850942127,"gamma":1.3232924840295135,"saturation":0.8601401146191838,"anisotropy":0.5438412313677659,"extinctionScale":-1.4065899672269264,"emissionScale":-0.54297934429073,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.11145774344228782,"Nx":128,"Ny":256,"Nz":128,"max_timesteps":500,"expansion":0},"SIMULATION_STATE":{"gravity":0.01407294740432927,"buoyancy":0.0056291789617317085,"radiationLoss":1,"blast_height":0.11764502834784088,"blast_radius":0.1,"blast_velocity":0,"blast_heat_flux":141.85530983563905,"dust_inflow_rate":9.569604234943904,"dust_absorption":[0.36759617341746326,0.3391003460207612,0.8235294117647058],"dust_scattering":[0.45146097654748174,0.6656546124793631,0.7549019607843137],"TtoKelvin":43.90759590150732,"collider_radius":0.46159267486200006},"CAMERA_STATE":{"pos":[302.4148626593571,225.416750761726,-301.17800376677013],"tar":[46.202378739626724,119.65020777952873,108.86732872268958],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.05,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n// Collision\\nuniform float collider_radius;            // {\\"name\\":\\"collider_radius\\",  \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01, \\"default\\":0.5}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature via either:\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//  - modification in-place, i.e. Dirichlet boundary conditions (v, T)\\n// Also specify the injected medium density inflow rate, and its scattering albedo.\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<400.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow.r = blast_heat_flux * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n      \\tmediumInflow = dust_extinction * dust_inflow_rate * radial_falloff;\\n      \\tmediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T.r *= radiationLoss;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n \\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density at current voxel\\n{\\n    // Boussinesq approximation (a la Fedkiw & Stam)\\n    float densityAvg = (medium.r + medium.g + medium.b)/3.0;\\n    float buoyancy_force = -densityAvg*gravity + buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdSphere(vec3 X, in vec3 C, float r) { return length(X-C) - r; }\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Return SDF of the collider surface.\\n\\t// (where the interior with SDF < 0.0 is a solid obstacle)\\n    return sdSphere(wsP, vec3(L.x/2.0, L.y/3.0, L.z/2.0), 0.5*L.x*collider_radius);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emission color.\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) :\\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275));\\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)),\\n             vec3(1.0),\\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}"}}
    `,

    'Plume & sphere collider II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":-0.1549211593365456,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"colliderSpec":[0.6666666666666667,0.6013071895424837,0.6013071895424837],"colliderDiffuse":[1,0,0],"colliderRoughness":0.341872424239417,"exposure":2.350729850942127,"gamma":1.3232924840295135,"saturation":0.8601401146191838,"anisotropy":0.5438412313677659,"extinctionScale":-1.1363893770638036,"emissionScale":1.689831280444583,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.14193219677294505,"Nx":160,"Ny":200,"Nz":160,"max_timesteps":150,"expansion":0.06616462420147567},"SIMULATION_STATE":{"gravity":0.008271107038050412,"buoyancy":0.0270200590163122,"radiationLoss":0.9948359613554485,"blast_height":0.1,"blast_radius":0.07278574193484362,"blast_velocity":0,"blast_heat_flux":51.832270771782575,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.5247606104630443,0.5783451399962777,0.11897711296939269],"dust_scattering":[0.9411644381390155,0.6458367660244194,0.6458367660244194],"TtoKelvin":76.09418475006379,"collider_radius":0.3859849951090192},"CAMERA_STATE":{"pos":[-94.27673602898626,113.2816247267118,-229.99156574188515],"tar":[82.2828994130199,103.10960926293166,87.96199208943263],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.05,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n// Collision\\nuniform float collider_radius;            // {\\"name\\":\\"collider_radius\\",  \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01, \\"default\\":0.5}\\n\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature via either:\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//  - modification in-place, i.e. Dirichlet boundary conditions (v, T)\\n// Also specify the injected medium density inflow rate, and its scattering albedo.\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<400.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow.r = blast_heat_flux * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n      \\tmediumInflow = dust_extinction * dust_inflow_rate * radial_falloff;\\n      \\tmediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T.r *= radiationLoss;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n \\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density at current voxel\\n{\\n    // Boussinesq approximation (a la Fedkiw & Stam)\\n    float densityAvg = (medium.r + medium.g + medium.b)/3.0;\\n    float buoyancy_force = -densityAvg*gravity + buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdSphere(vec3 X, in vec3 C, float r) { return length(X-C) - r; }\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Return SDF of the collider surface.\\n\\t// (where the interior with SDF < 0.0 is a solid obstacle)\\n    return sdSphere(wsP, L/2.0, 0.5*L.x*collider_radius);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emission color.\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) :\\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275));\\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)),\\n             vec3(1.0),\\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}"}}
    `,

    'Plume & walls': `
{"RENDERER_STATE":{"Nraymarch":32,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.1881091475283911,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"colliderSpec":[0.6666666666666667,0.6013071895424837,0.6013071895424837],"colliderDiffuse":[0.21568627450980393,0.21568627450980393,0.21568627450980393],"colliderRoughness":0.341872424239417,"exposure":2.350729850942127,"gamma":1.3232924840295135,"saturation":0.8601401146191838,"anisotropy":0.5438412313677659,"extinctionScale":-0.4418160704301233,"emissionScale":-0.07467155433950623,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":32,"vorticity_scale":0,"Nx":32,"Ny":512,"Nz":180,"max_timesteps":500,"expansion":0},"SIMULATION_STATE":{"gravity":0,"buoyancy":0.007719699902180384,"radiationLoss":1,"blast_height":0.1,"blast_radius":0.035290056695681755,"blast_velocity":16.542214076100823,"blast_heat_flux":148.87992668490742,"dust_inflow_rate":0.6616885630440329,"dust_absorption":[0.36759617341746326,0.3391003460207612,0.8235294117647058],"dust_scattering":[0.21914648212226065,0.5904064047764433,0.7450980392156863],"TtoKelvin":33.084428152201646,"collider_width":0.01,"collider_length":0.2,"collider_angle":30},"CAMERA_STATE":{"pos":[725.8330660275855,297.463024462745,99.85303278636057],"tar":[53.67074804236368,258.34810046615513,96.5296940918786],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.05,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n// Collision\\nuniform float collider_width;             // {\\"name\\":\\"collider_width\\",  \\"min\\":0.0, \\"max\\":0.05,    \\"step\\":0.01, \\"default\\":0.5}\\nuniform float collider_length;            // {\\"name\\":\\"collider_length\\", \\"min\\":0.0, \\"max\\":0.3,    \\"step\\":0.01, \\"default\\":0.5}\\nuniform float collider_angle;             // {\\"name\\":\\"collider_angle\\",  \\"min\\":0.0, \\"max\\":90.0,    \\"step\\":0.01, \\"default\\":0.5}\\n\\n \\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature via either:\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//  - modification in-place, i.e. Dirichlet boundary conditions (v, T)\\n// Also specify the injected medium density inflow rate, and its scattering albedo.\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<400.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow.r = blast_heat_flux * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n      \\tmediumInflow = dust_extinction * dust_inflow_rate * radial_falloff;\\n      \\tmediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T.r *= radiationLoss;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n \\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density at current voxel\\n{\\n    // Boussinesq approximation (a la Fedkiw & Stam)\\n    float densityAvg = (medium.r + medium.g + medium.b)/3.0;\\n    float buoyancy_force = -densityAvg*gravity + buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 X, vec3 bmin, vec3 bmax)\\n{\\n  vec3 d = abs(X-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nvoid rotateZY(inout vec3 v, float angle)\\n{\\n\\tfloat C = cos(angle);\\n    float S = sin(angle);\\n    v = vec3(v.x, C*v.z + S*v.y, -S*v.z + C*v.y);\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Return SDF of the collider surface.\\n\\t// (where the interior with SDF < 0.0 is a solid obstacle)\\n    float sdf = 1.0e6;\\n    vec3 E = vec3(0.5*L.x, collider_width*L.y, collider_length*L.z);\\n \\n    vec3 C1 = vec3(0.5*L.x, 0.25*L.y, 0.5*L.z); \\n    float A1 = radians(collider_angle);\\n    vec3 dX1 = wsP - C1;\\n    rotateZY(dX1, A1);  \\n    sdf = min(sdf, sdBox(dX1, -E, E));\\n    \\n    vec3 C2 = vec3(0.5*L.x, 0.35*L.y, 0.3*L.z); \\n    float A2 = radians(-collider_angle);\\n    vec3 dX2 = wsP - C2;\\n    rotateZY(dX2, A2);  \\n    sdf = min(sdf, sdBox(dX2, -E, E));\\n  \\n    vec3 C3 = vec3(0.5*L.x, 0.45*L.y, 0.5*L.z); \\n    float A3 = radians(collider_angle); \\n    vec3 dX3 = wsP - C3;\\n    rotateZY(dX3, A3);  \\n    sdf = min(sdf, sdBox(dX3, -E, E));\\n  \\n    vec3 C4 = vec3(0.5*L.x, 0.55*L.y, 0.3*L.z); \\n    float A4 = radians(-collider_angle);\\n    vec3 dX4 = wsP - C4;\\n    rotateZY(dX4, A4);  \\n    sdf = min(sdf, sdBox(dX4, -E, E));\\n   \\n    return sdf;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emission color.\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) :\\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275));\\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)),\\n             vec3(1.0),\\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}"}}
    `,

    'Dye collision': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[1,1,1],"sunPower":1.2348068034818107,"sunLatitude":48.954598239246906,"sunLongitude":166.7455178870963,"colliderSpec":[0.38235294117647056,0.35236447520184544,0.35236447520184544],"colliderDiffuse":[0.5,0.09342560553633233,0.03921568627450983],"colliderRoughness":0.09925328445660495,"exposure":2.350729850942127,"gamma":1.3232924840295135,"saturation":0.9594484164138477,"anisotropy":0.5659962658708779,"extinctionScale":-1.3681800586917703,"emissionScale":-10,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.29478225483611664,"Nx":400,"Ny":160,"Nz":160,"max_timesteps":1764,"expansion":0.06616462420147567},"SIMULATION_STATE":{"inject_radius":0.16542214076100822,"inject_offset":0,"inject_period":100,"inject_velocity":255.85291104369273,"swing_angle":19.850656891320988,"swing_period":49.62664222830247,"dye_inflow_rate":37.495685239161865,"dye1_absorption":[0,0,0],"dye1_scattering":[1,1,1],"dye2_absorption":[0.6274509803921569,0.6274509803921569,0.6274509803921569],"dye2_scattering":[0.18013433747201316,0.5294117647058824,0.07266435986159167]},"CAMERA_STATE":{"pos":[205.85960373981933,371.5731226119417,-544.9747275775544],"tar":[202.00925064526763,71.90921072184656,71.50614968220333],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Injection geometry \\nuniform float inject_radius;              // {\\"name\\":\\"inject_radius\\",     \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01, \\"default\\":0.1}\\nuniform float inject_offset;              // {\\"name\\":\\"inject_offset\\",     \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.01, \\"default\\":0.1}\\nuniform float inject_period;              // {\\"name\\":\\"inject_period\\",     \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.01, \\"default\\":25.0}\\nuniform float inject_velocity;            // {\\"name\\":\\"inject_velocity\\",   \\"min\\":0.0, \\"max\\":400.0,  \\"step\\":0.01,  \\"default\\":50.0}\\n\\nuniform float swing_angle;                // {\\"name\\":\\"swing_angle\\",    \\"min\\":0.0, \\"max\\":60.0,  \\"step\\":0.01,  \\"default\\":50.0}\\nuniform float swing_period;               // {\\"name\\":\\"swing_period\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Dust\\nuniform float dye_inflow_rate;            // {\\"name\\":\\"dye_inflow_rate\\",  \\"min\\":0.0, \\"max\\":100.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dye1_absorption;            // {\\"name\\":\\"dye1_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye1_scattering;            // {\\"name\\":\\"dye1_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye2_absorption;            // {\\"name\\":\\"dye2_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye2_scattering;            // {\\"name\\":\\"dye2_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.1415926;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}\\n\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    vec3 inject_center1 = vec3(0.1*L.x, 0.5*L.y, (0.5+inject_offset)*L.z);\\n    vec3 inject_center2 = vec3(0.9*L.x, 0.5*L.y, (0.5-inject_offset)*L.z);\\n  \\n    float r1 = length(wsP - inject_center1);\\n    float rt1 = r1/(inject_radius*L.y);\\n  \\n    float r2 = length(wsP - inject_center2);\\n    float rt2 = r2/(inject_radius*L.y);\\n  \\n    float vz = sin(radians(swing_angle) * sin(2.0*M_PI*time/swing_period));\\n    \\n    if (rt1 <= 1.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt1*rt1*(3.0 - 2.0*rt1));\\n        vInflow = vec3(1.0, 0.0, -vz) * inject_velocity * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        vec3 dye1_extinction = dye1_absorption + dye1_scattering;\\n        mediumInflow = dye1_extinction * dye_inflow_rate * radial_falloff;\\n        mediumAlbedo = dye1_scattering / dye1_extinction;\\n    }\\n    if (rt2 <= 1.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt2*rt2*(3.0 - 2.0*rt2));\\n        vInflow = vec3(-1.0, 0.0, vz) * inject_velocity * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        vec3 dye2_extinction = dye2_absorption + dye2_scattering;\\n        mediumInflow = dye2_extinction * dye_inflow_rate * radial_falloff;\\n      \\tmediumAlbedo = dye2_scattering / dye2_extinction;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density at current voxel\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n  \\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\\n{\\n      p = abs(p  )-b;\\n      vec3 q = abs(p+e)-e;\\n      return min(min(\\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\\n}\\n\\nvoid rotateXZ(inout vec3 v, float angle)\\n{\\n\\tfloat C = cos(angle);\\n    float S = sin(angle);\\n    v = vec3(C*v.x + S*v.z, v.y, -S*v.x + C*v.z);\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n  // Regions which are solid obstacles have SDF < 0.0\\n  vec3 C = L/2.0;  \\n  float H = 0.3*L.y;\\n  vec3 E = vec3(H);\\n  \\n  float angle = radians(60.0);//time/10.0;\\n  vec3 dX = wsP - C;\\n  rotateXZ(dX, angle);  \\n  return sdBoundingBox(dX, E, 0.03*L.x);\\n}     \\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}"}}
    `,

    'Dye collision II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[1,1,1],"sunPower":1.2348068034818107,"sunLatitude":53.88181426186247,"sunLongitude":166.17336295032,"colliderSpec":[0.38235294117647056,0.35236447520184544,0.35236447520184544],"colliderDiffuse":[0.5,0.09342560553633233,0.03921568627450983],"colliderRoughness":0.09925328445660495,"exposure":2.350729850942127,"gamma":1.0917861290226543,"saturation":0.9594484164138477,"anisotropy":-0.49270543499957475,"extinctionScale":-0.6320581640279892,"emissionScale":-10,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.2690765781069514,"Nx":400,"Ny":160,"Nz":160,"max_timesteps":1764,"expansion":0.06616462420147567},"SIMULATION_STATE":{"inject_radius":0.14155964757310155,"inject_offset":0.27745690924327904,"inject_period":100,"inject_velocity":396.3670132046843,"swing_angle":59.79479513487809,"swing_period":54.925143258363406,"dye_inflow_rate":65.11743788362672,"dye1_absorption":[1,1,1],"dye1_scattering":[0.08823529411764708,0.01557093425605537,0.01557093425605537],"dye2_absorption":[0.48039215686274506,0.48039215686274506,0.48039215686274506],"dye2_scattering":[0.1470588235294118,0.1470588235294118,0.1470588235294118]},"CAMERA_STATE":{"pos":[206.49009528069323,504.7720162875638,602.5131150614815],"tar":[206.60280858218326,63.20031934070458,78.22657023471508],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Injection geometry \\nuniform float inject_radius;              // {\\"name\\":\\"inject_radius\\",     \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01, \\"default\\":0.1}\\nuniform float inject_offset;              // {\\"name\\":\\"inject_offset\\",     \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.01, \\"default\\":0.1}\\nuniform float inject_period;              // {\\"name\\":\\"inject_period\\",     \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.01, \\"default\\":25.0}\\nuniform float inject_velocity;            // {\\"name\\":\\"inject_velocity\\",   \\"min\\":0.0, \\"max\\":400.0,  \\"step\\":0.01,  \\"default\\":50.0}\\n\\nuniform float swing_angle;                // {\\"name\\":\\"swing_angle\\",    \\"min\\":0.0, \\"max\\":60.0,  \\"step\\":0.01,  \\"default\\":50.0}\\nuniform float swing_period;               // {\\"name\\":\\"swing_period\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Dust\\nuniform float dye_inflow_rate;            // {\\"name\\":\\"dye_inflow_rate\\",  \\"min\\":0.0, \\"max\\":100.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dye1_absorption;            // {\\"name\\":\\"dye1_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye1_scattering;            // {\\"name\\":\\"dye1_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye2_absorption;            // {\\"name\\":\\"dye2_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dye2_scattering;            // {\\"name\\":\\"dye2_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.1415926;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}\\n\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    vec3 inject_center1 = vec3(0.1*L.x, 0.5*L.y, (0.5+inject_offset)*L.z);\\n    vec3 inject_center2 = vec3(0.9*L.x, 0.5*L.y, (0.5-inject_offset)*L.z);\\n  \\n    float r1 = length(wsP - inject_center1);\\n    float rt1 = r1/(inject_radius*L.y);\\n  \\n    float r2 = length(wsP - inject_center2);\\n    float rt2 = r2/(inject_radius*L.y);\\n  \\n    float vz = sin(radians(swing_angle) * sin(2.0*M_PI*time/swing_period));\\n    \\n    if (rt1 <= 1.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt1*rt1*(3.0 - 2.0*rt1));\\n        vInflow = vec3(1.0, 0.0, -vz) * inject_velocity * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        vec3 dye1_extinction = dye1_absorption + dye1_scattering;\\n        mediumInflow = dye1_extinction * dye_inflow_rate * radial_falloff;\\n        mediumAlbedo = dye1_scattering / dye1_extinction;\\n    }\\n    if (rt2 <= 1.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt2*rt2*(3.0 - 2.0*rt2));\\n        vInflow = vec3(-1.0, 0.0, vz) * inject_velocity * radial_falloff;\\n\\n        // Also inject absorbing/scattering \\"dust\\"\\n        vec3 dye2_extinction = dye2_absorption + dye2_scattering;\\n        mediumInflow = dye2_extinction * dye_inflow_rate * radial_falloff;\\n      \\tmediumAlbedo = dye2_scattering / dye2_extinction;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density at current voxel\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n  \\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\\n{\\n      p = abs(p  )-b;\\n      vec3 q = abs(p+e)-e;\\n      return min(min(\\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\\n}\\n\\nvoid rotateXZ(inout vec3 v, float angle)\\n{\\n\\tfloat C = cos(angle);\\n    float S = sin(angle);\\n    v = vec3(C*v.x + S*v.z, v.y, -S*v.x + C*v.z);\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n  // Regions which are solid obstacles have SDF < 0.0\\n  vec3 C = L/2.0;  \\n  float H = 0.3*L.y;\\n  vec3 E = vec3(H);\\n  \\n  float angle = radians(60.0);//time/10.0;\\n  vec3 dX = wsP - C;\\n  rotateXZ(dX, angle);\\n  return sdBoundingBox(dX, E, 0.02*L.x);\\n}     \\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}"}}
    `,

    'Ink mix': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":0.6392870967421813,"sunLatitude":31.0812622887005,"sunLongitude":83.36742649385936,"colliderSpec":[0.38235294117647056,0.35236447520184544,0.35236447520184544],"colliderDiffuse":[0.5,0.09342560553633233,0.03921568627450983],"colliderRoughness":0.09925328445660495,"exposure":2.572082697836626,"gamma":1.3232924840295135,"saturation":1,"anisotropy":0.5438412313677659,"extinctionScale":0.2198724926139093,"emissionScale":-10,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1.2130956989140604,"NprojSteps":8,"vorticity_scale":0.05458930645113272,"Nx":400,"Ny":64,"Nz":400,"max_timesteps":500,"expansion":0},"SIMULATION_STATE":{"inject_radius":0.15,"inject_period":400,"inject_angle":360,"inject_velocity":10,"ink_inflow_rate":0.08822514173920439},"CAMERA_STATE":{"pos":[-136.56344835616565,607.2760906365112,-289.5904468801808],"tar":[195.3731270391555,-7.663367095905049,179.35431289282414],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Injection geometry \\nuniform float inject_radius;              // {\\"name\\":\\"inject_radius\\",     \\"min\\":0.0, \\"max\\":0.2,    \\"step\\":0.01, \\"default\\":0.01}\\nuniform float inject_period;              // {\\"name\\":\\"inject_period\\",     \\"min\\":0.0, \\"max\\":400.0,  \\"step\\":0.01, \\"default\\":25.0}\\nuniform float inject_angle;               // {\\"name\\":\\"inject_angle\\",      \\"min\\":0.0, \\"max\\":360.0,  \\"step\\":0.01, \\"default\\":0.0}\\nuniform float inject_velocity;            // {\\"name\\":\\"inject_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":50.0}\\n\\n// Ink\\nuniform float ink_inflow_rate;            // {\\"name\\":\\"ink_inflow_rate\\",  \\"min\\":0.0, \\"max\\":1.0,     \\"step\\":0.01, \\"default\\":1.0}\\n\\nfloat length2(vec3 v) { return dot(v, v); }\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat cos60;\\nfloat sin60;\\nfloat M_PI = 3.1415926;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tcos60 = 0.5;\\n    sin60 = sqrt(3.0)/2.0;\\n  \\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nvoid rotateXZ(inout vec3 v, float angle)\\n{\\n\\tfloat C = cos(angle);\\n  \\tfloat S = sin(angle);\\n  \\tv = vec3(C*v.x + S*v.z, v.y, -S*v.x + C*v.z);\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    float scale = 0.2*L.x;\\n    vec3 origin = L/2.0;\\n    vec3 inject_center1 = origin + scale*vec3(-1.0, 0.0, 0.0);\\n    vec3 inject_center2 = origin + scale*vec3( 1.0, 0.0, 0.0);\\n  \\tvec3 inject_center3 = origin + scale*vec3( cos60, 0.0, sin60);\\n    vec3 inject_center4 = origin + scale*vec3(-cos60, 0.0, sin60);\\n    vec3 inject_center5 = origin + scale*vec3(-cos60, 0.0,-sin60);\\n    vec3 inject_center6 = origin + scale*vec3( cos60, 0.0,-sin60);\\n  \\n  \\tfloat R = 0.5*L.y * inject_radius;\\n    float R2 = R*R;\\n  \\tvec3 center;\\n    vec3 color;\\n    bool hit = false;\\n  \\tif      (length2(wsP - inject_center1) <= R2) { hit = true; center = inject_center1; color = vec3(1.0, 0.0, 0.0); }\\n\\telse if (length2(wsP - inject_center2) <= R2) { hit = true; center = inject_center2; color = vec3(1.0, 1.0, 0.0); }\\n    else if (length2(wsP - inject_center3) <= R2) { hit = true; center = inject_center3; color = vec3(0.0, 1.0, 0.0); }\\n    else if (length2(wsP - inject_center4) <= R2) { hit = true; center = inject_center4; color = vec3(0.0, 1.0, 1.0); }\\n    else if (length2(wsP - inject_center5) <= R2) { hit = true; center = inject_center5; color = vec3(0.0, 0.0, 1.0); }\\n  \\telse if (length2(wsP - inject_center6) <= R2) { hit = true; center = inject_center6; color = vec3(1.0, 0.0, 1.0); }\\n  \\n    if (hit)\\n    {\\n        float swing_angle = radians(inject_angle) * sin(2.0*M_PI*time/inject_period);\\n        float r = length(wsP - center);\\n        float radial_falloff = max(0.0, 1.0 - r*r*(3.0 - 2.0*r));\\n        vInflow = normalize(origin-center) * inject_velocity * radial_falloff;\\n        rotateXZ(vInflow, swing_angle);\\n\\n        // Also inject absorbing/scattering medium\\n      \\tmediumInflow = color * ink_inflow_rate * radial_falloff;\\n        mediumAlbedo = vec3(1.0);\\n    }\\n}\\n\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}"}}
    `,

    'Ink mix II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[1,1,1],"sunPower":2.293508504352264,"sunLatitude":29.103941347925925,"sunLongitude":190.5663061566815,"colliderSpec":[0.38235294117647056,0.35236447520184544,0.35236447520184544],"colliderDiffuse":[0.5,0.09342560553633233,0.03921568627450983],"colliderRoughness":0.09925328445660495,"exposure":3.2337712608806584,"gamma":1.3232924840295135,"saturation":0.9925328445660493,"anisotropy":-0.2721425806515638,"extinctionScale":-0.30947835782131694,"emissionScale":-10,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1.2130956989140604,"NprojSteps":8,"vorticity_scale":0.1746857806436247,"Nx":512,"Ny":3,"Nz":512,"max_timesteps":1000,"expansion":0},"SIMULATION_STATE":{"inject_radius":0.059551970673962965,"inject_period":163.21651221752813,"inject_angle":186.59617477841726,"inject_velocity":628.6041348918313,"ink_inflow_rate":0.4300975659786214},"CAMERA_STATE":{"pos":[754.6102156123451,607.8114656331106,256.5972348707234],"tar":[274.6357787142348,-83.4652411968122,254.96352781862745],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Injection geometry \\nuniform float inject_radius;              // {\\"name\\":\\"inject_radius\\",     \\"min\\":0.0, \\"max\\":0.2,    \\"step\\":0.01, \\"default\\":0.01}\\nuniform float inject_period;              // {\\"name\\":\\"inject_period\\",     \\"min\\":0.0, \\"max\\":400.0,  \\"step\\":0.01, \\"default\\":25.0}\\nuniform float inject_angle;               // {\\"name\\":\\"inject_angle\\",      \\"min\\":0.0, \\"max\\":360.0,  \\"step\\":0.01, \\"default\\":0.0}\\nuniform float inject_velocity;            // {\\"name\\":\\"inject_velocity\\",   \\"min\\":0.0, \\"max\\":1000.0,  \\"step\\":0.01, \\"default\\":50.0}\\n\\n// Ink\\nuniform float ink_inflow_rate;            // {\\"name\\":\\"ink_inflow_rate\\",  \\"min\\":0.0, \\"max\\":1.0,     \\"step\\":0.01, \\"default\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat cos60;\\nfloat sin60;\\nfloat M_PI = 3.1415926;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tcos60 = 0.5;\\n    sin60 = sqrt(3.0)/2.0;\\n  \\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);     \\n}\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nvoid rotateXZ(inout vec3 v, float angle)\\n{\\n\\tfloat C = cos(angle);\\n  \\tfloat S = sin(angle);\\n  \\tv = vec3(C*v.x + S*v.z, v.y, -S*v.x + C*v.z);\\n}\\n\\nfloat length2(vec2 v) { return dot(v, v); }\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    float scale = 0.333*L.x;\\n    vec3 origin = L/2.0;\\n    vec3 inject_center1 = origin + scale*vec3(-1.0, 0.0, 0.0);\\n    vec3 inject_center2 = origin + scale*vec3( 1.0, 0.0, 0.0);\\n  \\tvec3 inject_center3 = origin + scale*vec3( cos60, 0.0, sin60);\\n    vec3 inject_center4 = origin + scale*vec3(-cos60, 0.0, sin60);\\n    vec3 inject_center5 = origin + scale*vec3(-cos60, 0.0,-sin60);\\n    vec3 inject_center6 = origin + scale*vec3( cos60, 0.0,-sin60);\\n  \\n  \\tfloat R = 10.0*L.y * inject_radius;\\n    float R2 = R*R;\\n  \\tvec3 center;\\n    vec3 color;\\n    bool hit = false;\\n  \\tif      (length2(wsP.xz - inject_center1.xz) <= R2) { hit = true; center = inject_center1; color = vec3(1.0, 0.0, 0.0); }\\n\\telse if (length2(wsP.xz - inject_center2.xz) <= R2) { hit = true; center = inject_center2; color = vec3(1.0, 1.0, 0.0); }\\n    else if (length2(wsP.xz - inject_center3.xz) <= R2) { hit = true; center = inject_center3; color = vec3(0.0, 1.0, 0.0); }\\n    else if (length2(wsP.xz - inject_center4.xz) <= R2) { hit = true; center = inject_center4; color = vec3(0.0, 1.0, 1.0); }\\n    else if (length2(wsP.xz - inject_center5.xz) <= R2) { hit = true; center = inject_center5; color = vec3(0.0, 0.0, 1.0); }\\n  \\telse if (length2(wsP.xz - inject_center6.xz) <= R2) { hit = true; center = inject_center6; color = vec3(1.0, 0.0, 1.0); }\\n  \\n    if (hit)\\n    {\\n        float swing_angle = radians(inject_angle) * (-time/inject_period);\\n        float r = length(wsP.xz - center.xz);\\n        float radial_falloff = max(0.0, 1.0 - r*r*(3.0 - 2.0*r));\\n        vInflow = normalize(origin-center) * inject_velocity * radial_falloff;\\n        rotateXZ(vInflow, swing_angle);\\n\\n        // Also inject absorbing/scattering medium\\n      \\tmediumInflow = color * ink_inflow_rate * radial_falloff;\\n        mediumAlbedo = vec3(1.0);\\n    }\\n}\\n\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}"}}
    `,

    'Nuke': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0.09496347558631295,0.16027772123843773,0.37254901960784315],"sunColor":[1,1,1],"sunPower":0.7716248093509881,"sunLatitude":31.089007037058025,"sunLongitude":170.7156492653605,"colliderSpec":[0.3431372549019608,0.3431372549019608,0.3431372549019608],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.33084428152201645,"exposure":2.350729850942127,"gamma":1.8195271655405811,"saturation":1.0587017008704527,"anisotropy":0.5438412313677659,"extinctionScale":1.0252153442411718,"emissionScale":1.9338593988712205,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.613017588932583,"Nx":128,"Ny":300,"Nz":128,"max_timesteps":170,"expansion":0.055140713587002746},"SIMULATION_STATE":{"gravity":0.0005629178961731708,"buoyancy":0.004728510327854635,"radiationLoss":0.9926363988261646,"blast_height":0.09925328445660495,"blast_radius":0.08271107038050411,"blast_velocity":0.33775073770390246,"blast_heat_flux":191.39208469887808,"blast_duration":1.463586530050244,"dust_inflow_rate":0.33084428152201645,"dust_absorption":[0.31718569780853517,0.4901960784313726,0.46984191600515646],"dust_scattering":[0.7450980392156863,0.6999796458375737,0.48942714340638216],"TtoKelvin":52.93508504352263},"CAMERA_STATE":{"pos":[-356.8896727799308,229.9280740648457,457.9418419862361],"tar":[50.41672426144093,153.69365255298203,81.10486659006659],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.01,   \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":0.01,   \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.0, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":500.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float blast_duration;             // {\\"name\\":\\"blast_duration\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":1.0,   \\"default\\":100.0}\\n\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T.r = Tambient;\\n    if (wsP.y < L.y*0.05)\\n    {\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n\\t\\tmedium = dust_extinction;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n    {\\n        medium = vec3(0.0);\\n        mediumAlbedo = vec3(0.0);\\n    }\\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary values due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<=blast_duration)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = sin(M_PI*time/blast_duration) * dir * blast_velocity * radial_falloff;\\n        Tinflow.r = time/blast_duration * blast_heat_flux * radial_falloff;\\n    }\\n  \\tif (wsP.y < L.y*0.05)\\n    {\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n\\t\\tmediumInflow = dust_inflow_rate * dust_extinction;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\n    // Apply thermal relaxation due to \\"radiation loss\\" \\n    T.r *= radiationLoss;\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    // Boussinesq approximation (a la Fedkiw & Stam)\\n    float densityAvg = (medium.r + medium.g + medium.b)/3.0;\\n    float buoyancy_force = -densityAvg*gravity + buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emission color.\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n    mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n                                            vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n                                            vec3(1.0, 1.3302673723350029, 1.8993753891711275)) :\\n                                        mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n                                            vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n                                            vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275));\\n    return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)),\\n                vec3(1.0),\\n                smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Nuke II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0.09496347558631295,0.16027772123843773,0.37254901960784315],"sunColor":[1,1,1],"sunPower":0.7716248093509881,"sunLatitude":31.089007037058025,"sunLongitude":170.7156492653605,"colliderSpec":[0.3431372549019608,0.3431372549019608,0.3431372549019608],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.33084428152201645,"exposure":2.350729850942127,"gamma":1.8195271655405811,"saturation":1.0587017008704527,"anisotropy":0.5438412313677659,"extinctionScale":1.410911906093169,"emissionScale":-0.5157972630355285,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":10,"vorticity_scale":0.99,"Nx":192,"Ny":256,"Nz":192,"max_timesteps":170,"expansion":0.025},"SIMULATION_STATE":{"gravity":0.009925328445660495,"buoyancy":0.06616885630440329,"radiationLoss":0.9915335845544245,"blast_height":0.10917861290226544,"blast_radius":0.09373921309790466,"blast_velocity":1,"blast_heat_flux":170.9362121197085,"blast_duration":5.403789931526269,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.31718569780853517,0.4901960784313726,0.46984191600515646],"dust_scattering":[0.6920415224913494,0.8487685731732139,0.8823529411764706],"TtoKelvin":29.775985336981485},"CAMERA_STATE":{"pos":[-295.025270804485,313.2914673343268,-185.32422610082574],"tar":[93.77729064612959,93.02648543827851,110.8912667189282],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":2.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.0, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":500.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float blast_duration;             // {\\"name\\":\\"blast_duration\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":1.0,   \\"default\\":100.0}\\n\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T.r = Tambient;\\n    if (wsP.y < L.y*0.05)\\n    {\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n\\t\\tmedium = dust_extinction;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n    {\\n        medium = vec3(0.0);\\n        mediumAlbedo = vec3(0.0);\\n    }\\n}\\n\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary values due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<=blast_duration)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = sin(M_PI*time/blast_duration) * dir * blast_velocity * radial_falloff;\\n        Tinflow.r = time/blast_duration * blast_heat_flux * radial_falloff;\\n    }\\n  \\tif (wsP.y < L.y*0.05)\\n    {\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n\\t\\tmediumInflow = dust_inflow_rate * dust_extinction;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\n    // Apply thermal relaxation due to \\"radiation loss\\" \\n    T.r *= radiationLoss;\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    float buoyancy_force = gravity*buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emission color.\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n    mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n                                            vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n                                            vec3(1.0, 1.3302673723350029, 1.8993753891711275)) :\\n                                        mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n                                            vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n                                            vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275));\\n    return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)),\\n                vec3(1.0),\\n                smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Nuke III': `
{"RENDERER_STATE":{"Nraymarch":86,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.168637947177407,"sunLatitude":33.074072726190124,"sunLongitude":222.32735718279505,"colliderSpec":[0.5,0.5,0.5],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.2,"exposure":2.350729850942127,"gamma":1.8195271655405811,"saturation":1.025551675122873,"anisotropy":0.5438412313677659,"extinctionScale":0.8815610556579418,"emissionScale":1.9103941347925932,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.8952646257985766,"Nx":200,"Ny":400,"Nz":200,"max_timesteps":170,"expansion":0.09925328445660495},"SIMULATION_STATE":{"gravity":0.009925328445660495,"buoyancy":0.4190694232612209,"radiationLoss":0.9893279560109445,"blast_height":0.06947729911962346,"blast_radius":0.04962664222830247,"blast_velocity":0.14336585532620713,"blast_heat_flux":55,"blast_duration":5.403789931526269,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.49115724721261056,0.5175724268946335,0.7156862745098039],"dust_scattering":[0.3844675124951945,0.3844675124951942,0.7843137254901961],"TtoKelvin":82.71107038050411},"CAMERA_STATE":{"pos":[411.5489310326121,270.0141450334331,805.9451591191405],"tar":[100,200,100],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":2.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.0, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.5,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":500.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float blast_duration;             // {\\"name\\":\\"blast_duration\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":1.0,   \\"default\\":100.0}\\n\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T.r = Tambient;\\n    if (wsP.y < L.y*0.05)\\n    {\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n\\t\\tmedium = dust_extinction;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n    {\\n        medium = vec3(0.0);\\n        mediumAlbedo = vec3(0.0);\\n    }\\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary values due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    vec3 blast_center = vec3(0.5*L.x, blast_height*L.y, 0.5*L.z);\\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0 && time<=blast_duration)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = sin(M_PI*time/blast_duration) * dir * blast_velocity * radial_falloff;\\n        Tinflow.r = time/blast_duration * blast_heat_flux * radial_falloff;\\n    }\\n  \\tif (wsP.y < L.y*0.05)\\n    {\\n      \\tvec3 dust_extinction = dust_absorption + dust_scattering;\\n\\t\\tmediumInflow = dust_inflow_rate * dust_extinction;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\n    // Apply thermal relaxation due to \\"radiation loss\\" \\n    T.r *= radiationLoss;\\n}\\n\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    float buoyancy_force = gravity*buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emission color.\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n    mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n                                            vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n                                            vec3(1.0, 1.3302673723350029, 1.8993753891711275)) :\\n                                        mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n                                            vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n                                            vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275));\\n    return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)),\\n                vec3(1.0),\\n                smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}"}}
    `,

    'Vortex street': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0.5098039215686274,0.44482891195693963,0.44482891195693963],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.3009756597862143,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"colliderSpec":[0.3431372549019608,0.3431372549019608,0.3431372549019608],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.33084428152201645,"exposure":3.4543341152286704,"gamma":1.224123841631461,"saturation":1,"anisotropy":-0.051579726303552786,"extinctionScale":1.8079250439195889,"emissionScale":-3.1625515152116606,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":32,"vorticity_scale":0.0764250290315858,"Nx":512,"Ny":1024,"Nz":4,"max_timesteps":10000,"expansion":0},"SIMULATION_STATE":{"inflow_spacing":0.20953471163061044,"inflow_velocity":5.6,"collider_width":0.23159099706541153},"CAMERA_STATE":{"pos":[245.55864555665045,418.4850427112441,-1372.5953468829084],"tar":[248.7823608641542,506.8909315419636,49.185928351108736],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Inflow geometry \\nuniform float inflow_spacing;              // {\\"name\\":\\"inflow_spacing\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float inflow_velocity;             // {\\"name\\":\\"inflow_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Collider\\nuniform float collider_width;              // {\\"name\\":\\"collider_width\\",  \\"min\\":0.0, \\"max\\":1.0,   \\"step\\":0.01, \\"default\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat M_PI = 3.1415926;\\nvoid init()\\n{\\n\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);  \\n}\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    if (wsP.y <= 0.03*L.y)\\n    {\\n        v = vec3(0.0, 1.0, 0.0) * inflow_velocity;\\n      \\n        if (wsP.y >= 0.01*L.y)\\n        {\\n            float w = inflow_spacing*0.1*L.x;\\n            float ink = 0.0;\\n            float phase = 2.0*M_PI*wsP.x/w;\\n            if (cos(phase)>0.0) \\n              ink = 0.01; // * abs(sin(2.0* M_PI*time/500.0));\\n\\n            vec3 color = vec3(abs(cos(0.1*phase)), abs(cos(0.2*phase)), abs(cos(0.3*phase)));\\n            mediumInflow = ink * color;\\n            mediumAlbedo = vec3(0.0);\\n        }\\n\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 X, vec3 bmin, vec3 bmax)\\n{\\n  vec3 d = abs(X-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Return SDF of the collider surface.\\n    // (where the interior with SDF < 0.0 is a solid obstacle)\\n    vec3 C = vec3(L.x/2.0, L.y/5.0, 0.0);  \\n    float W = 0.5*L.x*collider_width;\\n    float H =  0.01*L.y;\\n  \\tvec3 E = vec3(W, H, 1.0e6);\\n    return sdBox(wsP, C-E, C+E);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Vortex street II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":96,"show_bounds":true,"skyColor":[0.5098039215686274,0.44482891195693963,0.44482891195693963],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.3009756597862143,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"colliderSpec":[0.3431372549019608,0.3431372549019608,0.3431372549019608],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.33084428152201645,"exposure":2.572082697836626,"gamma":1.7534746920666873,"saturation":1,"anisotropy":-0.051579726303552786,"extinctionScale":0.2,"emissionScale":-3.1625515152116606,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":32,"vorticity_scale":0.0764250290315858,"Nx":512,"Ny":1024,"Nz":2,"max_timesteps":10000,"expansion":0},"SIMULATION_STATE":{"inflow_spacing":0.20953471163061044,"inflow_velocity":5.5,"collider_width":0.08},"CAMERA_STATE":{"pos":[248.31203478022866,559.2990781973805,-1378.1112782461523],"tar":[237.9280951118418,530.3155421784738,46.08678261585806],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Inflow geometry \\nuniform float inflow_spacing;              // {\\"name\\":\\"inflow_spacing\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float inflow_velocity;             // {\\"name\\":\\"inflow_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Collider\\nuniform float collider_width;              // {\\"name\\":\\"collider_width\\",  \\"min\\":0.0, \\"max\\":1.0,   \\"step\\":0.01, \\"default\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat M_PI = 3.141592;\\nvoid init()\\n{\\n\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);  \\n}\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    if (wsP.y <= 0.03*L.y)\\n    {\\n        v = vec3(0.0, 1.0, 0.0) * inflow_velocity;\\n        if (wsP.y >= 0.01*L.y)\\n        {\\n            float w = inflow_spacing*0.1*L.x;\\n            float ink = 0.0;\\n            float phase = 2.0*M_PI*wsP.x/w;\\n            if (cos(phase)>0.0) \\n              ink = 1.0;\\n            vec3 color = vec3(abs(cos(0.1*phase)), abs(cos(0.2*phase)), abs(cos(0.3*phase)));\\n            mediumInflow = ink * color;\\n            mediumAlbedo = vec3(0.0);\\n        }\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 X, vec3 bmin, vec3 bmax)\\n{\\n  vec3 d = abs(X-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Return SDF of the collider surface.\\n    // (where the interior with SDF < 0.0 is a solid obstacle)\\n    vec3 C = vec3(L.x/2.0, L.y/5.0, 0.0);  \\n    float W = 0.5*L.x*collider_width;\\n    float H =  0.01*L.y;\\n  \\tvec3 E = vec3(W, H, 1.0e6);\\n    return sdBox(wsP, C-E, C+E);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Vortex street III': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":96,"show_bounds":true,"skyColor":[0.5098039215686274,0.44482891195693963,0.44482891195693963],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.3009756597862143,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"colliderSpec":[0.5,0.5,0.5],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.2,"exposure":3.4543341152286704,"gamma":1.4887992668490742,"saturation":0.6286041348918313,"anisotropy":-0.051579726303552786,"extinctionScale":0.48454791783152373,"emissionScale":-3.1625515152116606,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":76,"vorticity_scale":0.0764250290315858,"Nx":512,"Ny":1024,"Nz":2,"max_timesteps":10000,"expansion":0},"SIMULATION_STATE":{"inflow_spacing":0.16542214076100822,"inflow_velocity":8.601951319572429,"collider_width":0.20953471163061044},"CAMERA_STATE":{"pos":[252.8376472817318,477.49715276182314,-1269.5513435977102],"tar":[249.55344176778806,511.28659402261036,15.639395955077259],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Inflow geometry \\nuniform float inflow_spacing;              // {\\"name\\":\\"inflow_spacing\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float inflow_velocity;             // {\\"name\\":\\"inflow_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Collider\\nuniform float collider_width;              // {\\"name\\":\\"collider_width\\",  \\"min\\":0.0, \\"max\\":1.0,   \\"step\\":0.01, \\"default\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat M_PI = 3.141592;\\nvoid init()\\n{\\n\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);  \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    if (wsP.y <= 0.03*L.y)\\n    {\\n        v = vec3(0.0, 1.0, 0.0) * inflow_velocity;\\n        if (wsP.y >= 0.01*L.y)\\n        {\\n            float w = inflow_spacing*0.1*L.x;\\n            float ink = 0.0;\\n            float phase = 2.0*M_PI*wsP.x/w;\\n            if (cos(phase)>0.0) \\n              ink = 1.0; \\n            vec3 color = vec3(abs(cos(0.05*phase)), abs(sin(0.5*phase)), abs(sin(0.08*phase)));\\n            mediumInflow = ink * color;\\n            mediumAlbedo = vec3(0.0);\\n        }\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 X, vec3 bmin, vec3 bmax)\\n{\\n  vec3 d = abs(X-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Return SDF of the collider surface.\\n    // (where the interior with SDF < 0.0 is a solid obstacle)\\n    vec3 C = vec3(L.x/2.0, L.y/5.0, 0.0);  \\n    float W = 0.5*L.x*collider_width;\\n    float H =  0.01*L.y;\\n  \\tvec3 E = vec3(W, H, 1.0e6);\\n    return sdBox(wsP, C-E, C+E);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n "}}
    `,

    'Vortex street IV': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0.5098039215686274,0.44482891195693963,0.44482891195693963],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.3009756597862143,"sunLatitude":25.126446110567684,"sunLongitude":273.92154419410934,"colliderSpec":[0.3431372549019608,0.3431372549019608,0.3431372549019608],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.33084428152201645,"exposure":3.4543341152286704,"gamma":1.224123841631461,"saturation":1,"anisotropy":-0.051579726303552786,"extinctionScale":2.2049381817460088,"emissionScale":-3.1625515152116606,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":32,"vorticity_scale":0,"Nx":512,"Ny":1024,"Nz":4,"max_timesteps":10000,"expansion":0},"SIMULATION_STATE":{"inflow_spacing":0.20953471163061044,"inflow_velocity":4.962664222830247,"collider_width":0.08822514173920439},"CAMERA_STATE":{"pos":[263.7957084363256,465.95503803433115,-1369.547702497721],"tar":[259.65074612326106,528.3028333385018,53.61200738537287],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Inflow geometry \\nuniform float inflow_spacing;              // {\\"name\\":\\"inflow_spacing\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float inflow_velocity;             // {\\"name\\":\\"inflow_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01,  \\"default\\":50.0}\\n\\n// Collider\\nuniform float collider_width;              // {\\"name\\":\\"collider_width\\",  \\"min\\":0.0, \\"max\\":1.0,   \\"step\\":0.01, \\"default\\":1.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat M_PI = 3.1415926;\\nvoid init()\\n{\\n\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);  \\n}\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    if (wsP.y <= 0.03*L.y)\\n    {\\n        v = vec3(0.0, 1.0, 0.0) * inflow_velocity;\\n      \\n        if (wsP.y >= 0.01*L.y)\\n        {\\n            float w = inflow_spacing*0.1*L.x;\\n            float ink = 0.0;\\n            float phase = 2.0*M_PI*wsP.x/w;\\n            if (cos(phase)>0.0) \\n              ink = 0.01 * max(0.0, sin(2.0* M_PI*time/30.0));\\n\\n            vec3 color = vec3(abs(cos(0.1*phase)), abs(cos(0.2*phase)), abs(cos(0.3*phase)));\\n            mediumInflow = ink * color;\\n            mediumAlbedo = vec3(0.0);\\n        }\\n\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    return vec3(0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 X, vec3 bmin, vec3 bmax)\\n{\\n  vec3 d = abs(X-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Return SDF of the collider surface.\\n    // (where the interior with SDF < 0.0 is a solid obstacle)\\n    vec3 C = vec3(L.x/2.0, L.y/5.0, 0.0);  \\n    float W = 0.5*L.x*collider_width;\\n    float H =  0.01*L.y;\\n  \\tvec3 E = vec3(W, H, 1.0e6);\\n    return sdBox(wsP, C-E, C+E);\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Dust devil': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.7254901960784313,0.6790487821426148,0.4623221837754709],"sunPower":1.6979887976126342,"sunLatitude":19.178612902265442,"sunLongitude":230.26761993932345,"colliderSpec":[0.3431372549019608,0.3431372549019608,0.3431372549019608],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.33084428152201645,"exposure":1.689831280444583,"gamma":1.4887992668490742,"saturation":1.025551675122873,"anisotropy":0.3013208406532648,"extinctionScale":-2.9562326099974485,"emissionScale":1.6890836089273709,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.906182487088803,"Nx":160,"Ny":256,"Nz":160,"max_timesteps":200,"expansion":0},"SIMULATION_STATE":{"viscosity":0.2757035679350137,"circulation":0.40804128054382033,"buoyancy":0.6727167057614335,"A":0.4,"B":0,"scale_height":0.1621136979457881,"dust_inflow_rate":10,"dust_absorption":[0.8333333333333334,0.8213187235678586,0.6290849673202614],"dust_scattering":[0.4607843137254902,0.20355293213017622,0.06324490580545943],"TtoKelvin":82.7057802518446},"CAMERA_STATE":{"pos":[-370.169324081514,316.5993849464716,-129.51202859190022],"tar":[90.09918768541567,125.15041655058573,81.47518510214913],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\" \\nuniform float viscosity;                  // {\\"name\\":\\"viscosity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float circulation;                // {\\"name\\":\\"circulation\\", \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float A;                          // {\\"name\\":\\"A\\",           \\"min\\":0.0, \\"max\\":10.0,    \\"step\\":0.0001, \\"default\\":0.5}\\nuniform float B;                          // {\\"name\\":\\"B\\",           \\"min\\":0.0, \\"max\\":10.0,    \\"step\\":0.0001, \\"default\\":0.5}\\n\\n// injection geometry \\nuniform float scale_height;               // {\\"name\\":\\"scale_height\\",     \\"min\\":0.0, \\"max\\":0.3,    \\"step\\":0.001, \\"default\\":0.1}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);  \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    vec2 Xperp = (wsP - L/2.0).xz;\\n    float r = length(Xperp) / L.x;\\n    float rt = wsP.y/(scale_height*L.y);\\n    if (rt <= 1.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float zfalloff = exp(-10.0*rt*rt);\\n        float theta = atan(Xperp.y, Xperp.x);\\n        float vtheta = exp(-100.0*A*r*r) * circulation / (r + viscosity);\\n        float vx = -vtheta*sin(theta);\\n        float vz =  vtheta*cos(theta);\\n        if (r<0.3)\\n        \\tvInflow = vec3(vx, 0.0, vz);\\n   \\n        // Also inject absorbing/scattering \\"dust\\"\\n        vec3 dust_extinction = dust_absorption + dust_scattering;\\n        mediumInflow = dust_extinction * dust_inflow_rate * zfalloff;\\n      \\tmediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    vec2 Xperp = (wsP - L/2.0).xz;\\n    float r = length(Xperp) / L.x;\\n    float z = wsP.y / L.y;\\n    float fy = 1.0 * buoyancy * exp(-100.0*A*r*r);\\n    return vec3(0.0, fy, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 pW, vec3 bmin, vec3 bmax)\\n{\\n    vec3 d = abs(pW-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return sdBox(wsP, vec3(-1.0e3, 0.0, -1.0e3), vec3(1.0e3, 0.02*L.y, 1.0e3));\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n\\n"}}
    `,

    'Dust devil II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.7254901960784313,0.6790487821426148,0.4623221837754709],"sunPower":1.6979887976126342,"sunLatitude":72.7753865088321,"sunLongitude":134.9844668609827,"colliderSpec":[0.3431372549019608,0.3431372549019608,0.3431372549019608],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.33084428152201645,"exposure":1.689831280444583,"gamma":1.4887992668490742,"saturation":1.025551675122873,"anisotropy":0.3013208406532648,"extinctionScale":-1.5005177713005766,"emissionScale":1.6890836089273709,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":10,"vorticity_scale":0.5568109258015538,"Nx":160,"Ny":256,"Nz":160,"max_timesteps":200,"expansion":0},"SIMULATION_STATE":{"viscosity":0.12130956989140604,"circulation":0.1985065689132099,"buoyancy":0.09925328445660495,"A":0.7719699902180384,"B":3.4187242423941697,"scale_height":0.07940262756528395,"dust_inflow_rate":10,"dust_absorption":[0.8333333333333334,0.8213187235678586,0.6290849673202614],"dust_scattering":[0.4607843137254902,0.20355293213017622,0.06324490580545943],"TtoKelvin":82.7057802518446},"CAMERA_STATE":{"pos":[-287.8480943813848,290.052239198272,434.4030366498164],"tar":[83.14182135217739,110.82453511125604,83.31995919081363],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\" \\nuniform float viscosity;                  // {\\"name\\":\\"viscosity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float circulation;                // {\\"name\\":\\"circulation\\", \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float A;                          // {\\"name\\":\\"A\\",           \\"min\\":0.0, \\"max\\":10.0,    \\"step\\":0.0001, \\"default\\":0.5}\\nuniform float B;                          // {\\"name\\":\\"B\\",           \\"min\\":0.0, \\"max\\":10.0,    \\"step\\":0.0001, \\"default\\":0.5}\\n\\n// injection geometry \\nuniform float scale_height;               // {\\"name\\":\\"scale_height\\",     \\"min\\":0.0, \\"max\\":0.3,    \\"step\\":0.001, \\"default\\":0.1}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);  \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    vec2 Xperp = (wsP - L/2.0).xz;\\n    float r = length(Xperp) / L.x;\\n    float rt = wsP.y/(scale_height*L.y);\\n    if (rt <= 1.0)\\n    {\\n        // inject absorbing/scattering \\"dust\\"\\n        float zfalloff = exp(-10.0*rt*rt);\\n        vec3 dust_extinction = dust_absorption + dust_scattering;\\n        mediumInflow = dust_extinction * dust_inflow_rate * zfalloff;\\n      \\tmediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n    if (r<0.3)\\n    {\\n        float theta = atan(Xperp.y, Xperp.x);\\n        float vtheta = exp(-100.0*A*r*r) * circulation / (r + viscosity);\\n        float vx = -vtheta*sin(theta);\\n        float vz =  vtheta*cos(theta);\\n        vInflow = vec3(vx, 0.0, vz);\\n    }\\n} \\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    vec2 Xperp = (wsP - L/2.0).xz;\\n    float r = length(Xperp) / L.x;\\n    float z = wsP.y / L.y;\\n    float fy = 1.0 * buoyancy * exp(-100.0*A*r*r);\\n    return vec3(0.0, fy, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 pW, vec3 bmin, vec3 bmax)\\n{\\n    vec3 d = abs(pW-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return sdBox(wsP, vec3(-1.0e3, 0.0, -1.0e3), vec3(1.0e3, 0.02*L.y, 1.0e3));\\n}\\n","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n\\n"}}
    `,

    'Dust devil III': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[1,1,1],"sunPower":1.2348068034818107,"sunLatitude":19.178612902265442,"sunLongitude":218.35722580453088,"colliderSpec":[0.3431372549019608,0.3431372549019608,0.3431372549019608],"colliderDiffuse":[0.8,0.2,0.2],"colliderRoughness":0.33084428152201645,"exposure":1.689831280444583,"gamma":1.4887992668490742,"saturation":1.025551675122873,"anisotropy":-0.051579726303552786,"extinctionScale":-0.1771406452125106,"emissionScale":1.6890836089273709,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.5568109258015538,"Nx":128,"Ny":400,"Nz":128,"max_timesteps":200,"expansion":0},"SIMULATION_STATE":{"viscosity":0.07719699902180384,"circulation":0.37495685239161863,"buoyancy":0.23159099706541153,"A":1.7645028347840876,"scale_height":0.04300975659786214,"dust_inflow_rate":0.4411257086960219,"dust_absorption":[0.047481737793156474,0.37254901960784315,0.3534274147952147],"dust_scattering":[0.5588235294117647,0.23977203338082645,0.06574394463667822],"TtoKelvin":82.7057802518446},"CAMERA_STATE":{"pos":[492.71768940613987,321.74947535894637,-377.81991616305476],"tar":[78.41425626834838,210.1744589019207,41.28596733952731],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\" \\nuniform float viscosity;                  // {\\"name\\":\\"viscosity\\",   \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float circulation;                // {\\"name\\":\\"circulation\\", \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",    \\"min\\":0.0, \\"max\\":1.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float A;                          // {\\"name\\":\\"A\\",           \\"min\\":0.0, \\"max\\":10.0,    \\"step\\":0.0001, \\"default\\":0.5}\\n\\n// injection geometry \\nuniform float scale_height;               // {\\"name\\":\\"scale_height\\",     \\"min\\":0.0, \\"max\\":0.3,    \\"step\\":0.001, \\"default\\":0.1}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n}","initial_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation, \\n// i.e. populate all the relevant fields (velocity, temperature, debris density/albedo) at time 0.0\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(0.0);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);  \\n}\\n\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature and medium fields via:\\n//\\n//  - specification of boundary   inflow/outflow      due to Dirichlet BC (i.e. v, T are modified in-place)\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo (defaults to 0.5)\\n{\\n    vec2 Xperp = (wsP - L/2.0).xz;\\n    float r = length(Xperp) / L.x;\\n    float rt = wsP.y/(scale_height*L.y);\\n    if (rt <= 1.0)\\n    {\\n        // inject absorbing/scattering \\"dust\\"\\n        float zfalloff = exp(-10.0*rt*rt);\\n        vec3 dust_extinction = dust_absorption + dust_scattering;\\n        mediumInflow = dust_extinction * dust_inflow_rate * zfalloff;\\n      \\tmediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n    if (r<0.3)\\n    {\\n        float theta = atan(Xperp.y, Xperp.x);\\n        float vtheta = exp(-100.0*A*r*r) * circulation / (r + viscosity);\\n        float vx = -vtheta*sin(theta);\\n        float vz =  vtheta*cos(theta);\\n        vInflow = vec3(vx, 0.0, vz);\\n    }\\n} \\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    vec2 Xperp = (wsP - L/2.0).xz;\\n    float r = length(Xperp) / L.x;\\n    float z = wsP.y / L.y;\\n    float fy = 1.0 * buoyancy * exp(-100.0*A*r*r);\\n    return vec3(0.0, fy, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable, static collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfloat sdBox(vec3 pW, vec3 bmin, vec3 bmax)\\n{\\n    vec3 d = abs(pW-0.5*(bmin+bmax)) - 0.5*(bmax-bmin);\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return sdBox(wsP, vec3(-1.0e3, 0.0, -1.0e3), vec3(1.0e3, 0.02*L.y, 1.0e3));\\n}","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field and phase function\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n  \\treturn vec3(0.0);\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify phase function of medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Moving fireball': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.367144516090617,"sunLatitude":76.73485298771871,"sunLongitude":138.94571082309892,"colliderSpec":[0.6666666666666667,0.6013071895424837,0.6013071895424837],"colliderDiffuse":[1,0,0],"colliderRoughness":0.341872424239417,"exposure":0.3664541543565143,"gamma":1.5549681231534773,"saturation":1.025551675122873,"anisotropy":0.5438412313677659,"extinctionScale":-1.5005177713005766,"emissionScale":1.0281427174005486,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":16,"vorticity_scale":0.43671445160906175,"Nx":160,"Ny":160,"Nz":160,"max_timesteps":500,"expansion":0.1},"SIMULATION_STATE":{"gravity":0.029775985336981482,"buoyancy":0.009925328445660495,"radiationLoss":0.9970476559131248,"blast_height":0.1,"blast_radius":0.08932795601094444,"blast_velocity":48.523827956562414,"blast_heat_flux":49.62664222830247,"animation_period":13.233771260880658,"dust_inflow_rate":4.962346815110676,"dust_absorption":[0.7024221453287197,0.7451658864237736,0.8235294117647058],"dust_scattering":[0.5613225682429838,0.5613225682429834,0.7843137254901961],"TtoKelvin":52.93508504352263},"CAMERA_STATE":{"pos":[428.5065222671221,231.18004269182862,-137.9063177523132],"tar":[95.47877293559753,48.26456077993378,85.76052711016654],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.3,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float animation_period;           // {\\"name\\":\\"animation_period\\", \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"///////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation (velocity, temperature, and medium density/albedo)\\n// at time 0.0 (if unspecified, all quantities default to zero).\\n///////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature via either:\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//  - modification in-place, i.e. Dirichlet boundary conditions (v, T)\\n// Also specify the injected medium density inflow rate, and its scattering albedo.\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    float phase = 0.05*M_PI*time/animation_period;\\n    vec3 blast_center = 0.5*L + 0.5*vec3(0.5*L.x*sin(13.0*phase),\\n                                         0.5*L.y*sin(17.0*phase),\\n                                         0.5*L.z*sin(19.0*phase));\\n  \\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow.r = blast_heat_flux * radial_falloff;\\n\\n      \\t// Also inject absorbing/scattering \\"dust\\"\\n        vec3 dust_extinction = dust_absorption + dust_scattering;\\n        mediumInflow = dust_extinction * dust_inflow_rate * radial_falloff;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T.r *= radiationLoss;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    // Boussinesq approximation (a la Fedkiw & Stam)\\n    float densityAvg = (medium.r + medium.g + medium.b)/3.0;\\n    float buoyancy_force = -densityAvg*gravity + buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emiss\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify the phase function of the scattering medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Moving fireball II': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":2.318481723990864,"sunLatitude":60.52306766011881,"sunLongitude":0,"colliderSpec":[0.6666666666666667,0.6013071895424837,0.6013071895424837],"colliderDiffuse":[0.6147635524798154,0.64814437885881,0.803921568627451],"colliderRoughness":0.341872424239417,"exposure":0.3664541543565143,"gamma":0.9594484164138477,"saturation":1.4887992668490742,"anisotropy":0.5438412313677659,"extinctionScale":-1.7651931965181893,"emissionScale":-2.500862952167627,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":23,"vorticity_scale":0.22352675547527642,"Nx":128,"Ny":200,"Nz":128,"max_timesteps":500,"expansion":0.016724785295568756},"SIMULATION_STATE":{"gravity":0.004411257086960219,"buoyancy":0.04411257086960219,"radiationLoss":0.9434844417684788,"blast_height":0.1,"blast_radius":0.08601951319572428,"blast_velocity":51.832270771782575,"blast_heat_flux":200,"animation_period":24.261913978281207,"dust_inflow_rate":5.184683441626314,"dust_absorption":[0,0,0],"dust_scattering":[0.8674548250672819,0.87873442341181,0.9313725490196079],"TtoKelvin":2.5087177943353134},"CAMERA_STATE":{"pos":[419.65356811528306,221.54997814431192,-184.40375823705278],"tar":[43.18632881054206,66.65170079206099,85.67369005710059],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.1,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":2.0,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.3,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":200.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float animation_period;           // {\\"name\\":\\"animation_period\\", \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"///////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation (velocity, temperature, and medium density/albedo)\\n// at time 0.0 (if unspecified, all quantities default to zero).\\n///////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature via either:\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//  - modification in-place, i.e. Dirichlet boundary conditions (v, T)\\n// Also specify the injected medium density inflow rate, and its scattering albedo.\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    float phase = 0.05*M_PI*time/animation_period;\\n    vec3 blast_center = 0.5*L + 0.5*vec3(0.5*L.x*sin(13.0*phase),\\n                                         0.5*L.y*sin(17.0*phase),\\n                                         0.5*L.z*sin(19.0*phase));\\n  \\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow.r = blast_heat_flux * radial_falloff;\\n\\n      \\t// Also inject absorbing/scattering \\"dust\\"\\n        vec3 dust_extinction = dust_absorption + dust_scattering;\\n        mediumInflow = dust_extinction * dust_inflow_rate * radial_falloff;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T.r *= radiationLoss;\\n    }\\n}\\n","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    // Tbuoyancy is the reference temperature for buoyancy\\n    float buoyancy_force = gravity*buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emiss\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify the phase function of the scattering medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `,

    'Moving fireball III': `
{"RENDERER_STATE":{"Nraymarch":64,"spp_per_frame":1,"max_spp":32,"show_bounds":true,"skyColor":[0,0,0],"sunColor":[0.5489273590657855,0.5489273590657855,0.5489273590657855],"sunPower":1.6979887976126342,"sunLatitude":-12.58243812384815,"sunLongitude":91.31302170007655,"colliderSpec":[0.6666666666666667,0.6013071895424837,0.6013071895424837],"colliderDiffuse":[0.6147635524798154,0.64814437885881,0.803921568627451],"colliderRoughness":0.341872424239417,"exposure":0.3664541543565143,"gamma":0.9594484164138477,"saturation":1.4887992668490742,"anisotropy":-0.051579726303552786,"extinctionScale":-2.029868621735803,"emissionScale":-1.8391743891235937,"blackbodyEmission":-11.619147601146414,"TtoKelvin":0.9924693630221351},"SOLVER_STATE":{"timestep":1,"NprojSteps":23,"vorticity_scale":0.1528500580631716,"Nx":64,"Ny":256,"Nz":128,"max_timesteps":1000,"expansion":0},"SIMULATION_STATE":{"gravity":0.0003308442815220165,"buoyancy":0.0012130956989140605,"radiationLoss":0.9860195131957243,"blast_height":0.4881906236524993,"blast_radius":0.08271107038050411,"blast_velocity":1.4336585532620714,"blast_heat_flux":44.112570869602195,"animation_period":15.439399804360768,"dust_inflow_rate":1.985065689132099,"dust_absorption":[0.4659746251441753,0.4659746251441753,0.47058823529411764],"dust_scattering":[0.8223760092272203,0.8411018386593392,0.9019607843137255],"TtoKelvin":13.233771260880658},"CAMERA_STATE":{"pos":[410.643261895476,162.7336190799166,69.48707321629786],"tar":[-28.382639151179635,122.68482185517172,76.17773010829605],"near":1,"far":20000},"GUI_STATE":{"visible":true},"EDITOR_STATE":{"common_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Bind UI parameters to uniforms used in the various programs\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// \\"Physics\\"\\nuniform float gravity;                    // {\\"name\\":\\"gravity\\",      \\t \\"min\\":0.0, \\"max\\":0.01,    \\"step\\":0.001, \\"default\\":0.05}\\nuniform float buoyancy;                   // {\\"name\\":\\"buoyancy\\",         \\"min\\":0.0, \\"max\\":0.01,    \\"step\\":0.001, \\"default\\":0.5}\\nuniform float radiationLoss;              // {\\"name\\":\\"radiationLoss\\",    \\"min\\":0.9, \\"max\\":1.0,    \\"step\\":0.01,  \\"default\\":0.999}\\n\\n// Blast geometry \\nuniform float blast_height;               // {\\"name\\":\\"blast_height\\",     \\"min\\":0.1, \\"max\\":0.9,    \\"step\\":0.001, \\"default\\":0.25}\\nuniform float blast_radius;               // {\\"name\\":\\"blast_radius\\",     \\"min\\":0.0, \\"max\\":0.3,    \\"step\\":0.001, \\"default\\":0.1}\\nuniform float blast_velocity;             // {\\"name\\":\\"blast_velocity\\",   \\"min\\":0.0, \\"max\\":10.0,  \\"step\\":0.1,   \\"default\\":50.0}\\nuniform float blast_heat_flux;            // {\\"name\\":\\"blast_heat_flux\\",  \\"min\\":0.0, \\"max\\":200.0,  \\"step\\":1.0,   \\"default\\":100.0}\\nuniform float animation_period;           // {\\"name\\":\\"animation_period\\", \\"min\\":0.0, \\"max\\":100.0,  \\"step\\":1.0,   \\"default\\":100.0}\\n\\n// Dust\\nuniform float dust_inflow_rate;           // {\\"name\\":\\"dust_inflow_rate\\", \\"min\\":0.0, \\"max\\":10.0,   \\"step\\":0.01, \\"default\\":1.0}\\nuniform vec3  dust_absorption;            // {\\"name\\":\\"dust_absorption\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\nuniform vec3  dust_scattering;            // {\\"name\\":\\"dust_scattering\\",  \\"default\\":[0.5,0.5,0.5], \\"scale\\":1.0}\\n\\n// Rendering\\nuniform float TtoKelvin;                  // {\\"name\\":\\"TtoKelvin\\",        \\"min\\":0.0, \\"max\\":300.0,  \\"step\\":0.01, \\"default\\":10.0}\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat Tambient;\\nfloat M_PI = 3.141592;\\n\\nvoid init()\\n{\\n\\t// Any global constants defined here are available in all functions\\n \\tTambient = 1.0;\\n}","initial_glsl":"///////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the initial conditions for the simulation (velocity, temperature, and medium density/albedo)\\n// at time 0.0 (if unspecified, all quantities default to zero).\\n///////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid initial_conditions(in vec3 wsP,               // world space center of current voxel\\n                        in vec3 L, in float dL,    // world-space extents of grid, and voxel-size\\n                        inout vec3 v,              // initial velocity\\n                        inout vec4 T,              // initial temperature\\n                        inout vec3 medium,         // initial per-channel medium density (extinction)\\n                        inout vec3 mediumAlbedo)   // initial per-channel medium albedo\\n{\\n    v = vec3(0.0);\\n    T = vec4(Tambient);\\n    medium = vec3(0.0);\\n    mediumAlbedo = vec3(0.0);\\n}\\n","inject_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Update the velocity, temperature via either:\\n//  - specification of volumetric inflow/outflow rate due to sources/sinks (vInflow, Tinflow)\\n//  - modification in-place, i.e. Dirichlet boundary conditions (v, T)\\n// Also specify the injected medium density inflow rate, and its scattering albedo.\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvoid inject(in vec3 wsP,                 // world space center of current voxel\\n            in float time,               // time\\n            in vec3 L, in float dL,      // world-space extents of grid, and voxel-size\\n            inout vec3 v,                // modify velocity in-place (defaults to no change)\\n            inout vec3 vInflow,          // velocity inflow rate (defaults to zero)\\n            inout vec4 T,                // modify temperature in-place (defaults to no change)\\n            inout vec4 Tinflow,          // temperature inflow rate (defaults to zero)\\n            inout vec3 mediumInflow,     // medium density (extinction) inflow rate (defaults to zero)\\n            inout vec3 mediumAlbedo)     // medium albedo\\n{\\n    float phase = 0.05*M_PI*time/animation_period;\\n    vec3 C = vec3(0.5*L.x, L.y*blast_height, 0.5*L.z);\\n    vec3 blast_center = C + 0.5*vec3(0.5*L.x*sin(3.0*phase),\\n                                     0.5*L.y*sin(7.0*phase),\\n                                     0.5*L.z*sin(17.0*phase));\\n  \\n    vec3 dir = wsP - blast_center;\\n    float r = length(dir);\\n    dir /= r;\\n    float rt = r/(blast_radius*L.y);\\n    if (rt <= 1.0)\\n    {\\n        // Within blast radius: inject velocity and temperature\\n        float radial_falloff = max(0.0, 1.0 - rt*rt*(3.0 - 2.0*rt));\\n        vInflow = dir * blast_velocity * radial_falloff;\\n        Tinflow.r = blast_heat_flux * radial_falloff;\\n\\n      \\t// Also inject absorbing/scattering \\"dust\\"\\n        vec3 dust_extinction = dust_absorption + dust_scattering;\\n        mediumInflow = dust_extinction * dust_inflow_rate * radial_falloff;\\n        mediumAlbedo = dust_scattering / dust_extinction;\\n    }\\n  \\telse\\n  \\t{\\n        // Apply thermal relaxation due to \\"radiation loss\\" \\n        T.r *= radiationLoss;\\n    }\\n}","influence_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Apply any external forces to the fluid\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nvec3 externalForces(in vec3 wsP,                       // world space center of current voxel\\n                    in float time,                     // time\\n                    in vec3 L, in float dL,            // world-space extents of grid, and voxel-size\\n                    in vec3 v, in float P, in vec4 T,  // velocity, pressure, temperature at current voxel\\n                    in vec3 medium)                    // medium density (extinction) at current voxel\\n{\\n    // Boussinesq approximation (a la Fedkiw & Stam)\\n    float densityAvg = (medium.r + medium.g + medium.b)/3.0;\\n    float buoyancy_force = -densityAvg*gravity + buoyancy*(T.r - Tambient);\\n    return vec3(0.0, buoyancy_force, 0.0);\\n}","collide_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify regions which contain impenetrable collider material\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n/******************************************************/\\n/*                 mandatory function                 */\\n/******************************************************/\\n\\nfloat collisionSDF(in vec3 wsP,            // world space center of current voxel\\n                   in float time,          // time\\n                   in vec3 L, in float dL) // world-space extents of grid, and voxel-size\\n{\\n    // Regions which are solid obstacles have SDF < 0.0\\n    return 1.0e6;\\n}","render_glsl":"//////////////////////////////////////////////////////////////////////////////////////////////////////\\n// Specify the fluid emission field \\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n// Approximate map from temperature in Kelvin to blackbody emiss\\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\\nvec3 colorTemperatureToRGB(const in float temperature)\\n{\\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \\n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\\n\\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\\n\\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \\n\\t \\t\\t\\t\\t\\t\\t\\t\\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\\n   \\t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\\n\\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \\n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), \\n             vec3(1.0), \\n             smoothstep(1000.0, 0.0, temperature));\\n}\\n\\n\\n/******************************************************/\\n/*                 mandatory functions                */\\n/******************************************************/\\n\\n// Specify how the temperature is mapped to the local emission radiance\\nvec3 temperatureToEmission(in vec4 T)\\n{\\n    vec3 emission = colorTemperatureToRGB(T.r * TtoKelvin) * pow(T.r/100.0, 4.0);\\n  \\treturn emission;\\n}\\n\\n// Optionally remap the medium density (extinction) and albedo\\nvoid mediumRemap(inout vec3 medium,\\n                 inout vec3 mediumAlbedo)\\n{}\\n\\n// Specify the phase function of the scattering medium\\nfloat phaseFunction(float mu,         // cosine of angle between incident and scattered ray\\n                    float anisotropy) // anisotropy coefficient\\n{\\n    const float pi = 3.141592653589793;\\n    float g = anisotropy;\\n    float gSqr = g*g;\\n    return (1.0/(4.0*pi)) * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\\n}\\n"}}
    `

};


var Presets = function()
{
    this.preset_names = [];
    for (var preset_name in _presets_table) {
        if (_presets_table.hasOwnProperty(preset_name)) {
            this.preset_names.push(preset_name);
        }
    }
}

Presets.prototype.get_preset_names = function()
{
    return this.preset_names;
}

Presets.prototype.get_preset = function(preset_name)
{
    return this.preset_names[preset_name];
}

Presets.prototype.load_preset = function(preset_name)
{
    if (preset_name in _presets_table)
    {
        let preset = _presets_table[preset_name];
        let state = JSON.parse(preset);
        trinity.preset_selection = preset_name;
        trinity.load_state(state);
    }
}

